<!doctype html><html lang=en-us dir=ltr><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="
  Data Models and Query Languages
  #

Most applications are built by layering one data model on top of another. Each layer hides the complexity of the layer below it by providing a clean data model.

  Relational model v/s Document model
  #

SQL based on relational model proposed by Edgar Codd in 1970. Data is organized into relations (tables in SQL) where each relation is an unordered collection of tuples (rows in SQL)."><meta name=theme-color media="(prefers-color-scheme: light)" content="#ffffff"><meta name=theme-color media="(prefers-color-scheme: dark)" content="#343a40"><meta name=color-scheme content="light dark"><meta property="og:url" content="https://shantanugoel.com/notes/books/ddia/chapter-2/"><meta property="og:site_name" content="Shantanu's Notesverse"><meta property="og:title" content="Chapter 2: Data Models and Query Languages"><meta property="og:description" content="Data Models and Query Languages # Most applications are built by layering one data model on top of another. Each layer hides the complexity of the layer below it by providing a clean data model.
Relational model v/s Document model # SQL based on relational model proposed by Edgar Codd in 1970. Data is organized into relations (tables in SQL) where each relation is an unordered collection of tuples (rows in SQL)."><meta property="og:locale" content="en_us"><meta property="og:type" content="article"><meta property="article:section" content="books"><title>Chapter 2: Data Models and Query Languages | Shantanu's Notesverse</title>
<link rel=icon href=/notes/favicon.png><link rel=manifest href=/notes/manifest.json><link rel=canonical href=https://shantanugoel.com/notes/books/ddia/chapter-2/><link rel=stylesheet href=/notes/book.min.6c8b9d2a1fc95075ed7da46ca81060b39add8fff6741ac51259f768929281e2c.css integrity="sha256-bIudKh/JUHXtfaRsqBBgs5rdj/9nQaxRJZ92iSkoHiw=" crossorigin=anonymous><script defer src=/notes/fuse.min.js></script><script defer src=/notes/en.search.min.d8cc77086cfe8689b76b9dabc9fcd00152dbb02bab8451c4ef808f6764fbf60b.js integrity="sha256-2Mx3CGz+hom3a52ryfzQAVLbsCurhFHE74CPZ2T79gs=" crossorigin=anonymous></script></head><body dir=ltr><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><div class=book-menu-content><nav><h2 class=book-brand><a class="flex align-center" href=/notes/><span>Shantanu's Notesverse</span></a></h2><div class="book-search hidden"><input type=text id=book-search-input placeholder=Search aria-label=Search maxlength=64 data-hotkeys=s/><div class="book-search-spinner hidden"></div><ul id=book-search-results></ul></div><script>document.querySelector(".book-search").classList.remove("hidden")</script><ul><li><a href=https://shantanugoel.com target=_blank rel=noopener>Blog</a></li></ul><ul><li><a href=/notes/books/>Books</a><ul><li><input type=checkbox id=section-e9d75868e6793f3a69534dc012457820 class=toggle checked>
<label for=section-e9d75868e6793f3a69534dc012457820 class="flex justify-between"><a href=/notes/books/ddia/>Designing Data-Intensive Applications</a></label><ul><li><a href=/notes/books/ddia/chapter-1/>Chapter 1: Foundations of Data Systems</a></li><li><a href=/notes/books/ddia/chapter-2/ class=active>Chapter 2: Data Models and Query Languages</a></li><li><a href=/notes/books/ddia/chapter-3/>Chapter 3: Storage and Retrieval</a></li></ul></li></ul></li><li><a href=/notes/travel/>Travel</a><ul><li><a href=/notes/travel/china/china/>China</a></li><li><a href=/notes/travel/hongkong/hk/>Hong Kong</a></li><li><a href=/notes/travel/japan/japan/>Japan</a></li></ul></li><li><a href=/notes/braindump/>Braindump</a><ul><li><a href=/notes/braindump/hugo-multiple-themes/>Multiple Hugo Themes For Different Paths In Same Site</a></li></ul></li></ul></nav><script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script></div></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/notes/svg/menu.svg class=book-icon alt=Menu></label><h3>Chapter 2: Data Models and Query Languages</h3><label for=toc-control><img src=/notes/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class="hidden clearfix"><nav id=TableOfContents><ul><li><a href=#relational-model-vs-document-model>Relational model v/s Document model</a><ul><li><a href=#birth-of-nosql>Birth of NoSQL</a></li><li><a href=#object-relational-mismatch>Object Relational Mismatch</a></li><li><a href=#many-to-one-and-many-to-many-relationships>Many to one and Many to Many relationships</a></li><li><a href=#hierarchical-model>Hierarchical Model</a></li><li><a href=#network-model>Network Model</a></li><li><a href=#relational-model>Relational Model</a></li><li><a href=#comparison-to-document-dbs>Comparison to Document DBs</a></li><li><a href=#relational-vs-document-dbs-today>Relational v/s Document DBs today:</a></li><li><a href=#schema-flexibility-in-document-model>Schema Flexibility in Document model</a></li><li><a href=#data-locality>Data Locality</a></li></ul></li><li><a href=#query-languages-for-data>Query Languages for Data</a><ul><li><a href=#map-reduce-querying>Map Reduce Querying</a></li></ul></li><li><a href=#graph-like-data-models>Graph like Data Models</a><ul><li><a href=#property-graphs>Property Graphs</a></li><li><a href=#triple-store-model-and-sparql>Triple Store Model and SPARQL</a></li></ul></li></ul></nav></aside></header><article class="markdown book-article"><h1 id=data-models-and-query-languages>Data Models and Query Languages
<a class=anchor href=#data-models-and-query-languages>#</a></h1><p>Most applications are built by layering one data model on top of another. Each layer hides the complexity of the layer below it by providing a clean data model.</p><h2 id=relational-model-vs-document-model>Relational model v/s Document model
<a class=anchor href=#relational-model-vs-document-model>#</a></h2><p>SQL based on relational model proposed by Edgar Codd in 1970. Data is organized into relations (tables in SQL) where each relation is an unordered collection of tuples (rows in SQL).</p><p>Goal of relational model was to hide the implementation detail behind a cleaner interface.</p><p>Other competing alternatives that came and went -> Network model, Hierarchical model, XML DBs etc.</p><h3 id=birth-of-nosql>Birth of NoSQL
<a class=anchor href=#birth-of-nosql>#</a></h3><p>The name NoSQL originated as a catch twitter hashtag for an OSS distributed DB meetup. Retroactively reinterpreted as <strong>Not Only SQL</strong>.</p><p>Driving forces behind NoSQL:</p><ul><li>Greater scalability</li><li>Free and OSS preference over commercial DBs</li><li>More dynamic data models</li></ul><h3 id=object-relational-mismatch>Object Relational Mismatch
<a class=anchor href=#object-relational-mismatch>#</a></h3><p>A translation layer is required between application code and the DB model. Difference between these models is called <strong>impedance mismatch</strong>.</p><p>Object Relational Mapping (ORM) frameworks reduce the boilerplate code required for this translation layer, but don&rsquo;t completely hide the complexity.</p><p>Example for options to store a linkedin profile data in DB:</p><ul><li>Relational<ol><li>Save the varying info (education, companies, cities, etc) in separate tables with foreign key references to the users table</li><li>Save this info in structured data types like XML or JSON within the same row with querying/indexing support</li><li>Encode as XML or JSON and save in a text field column of same row, but this loses querying etc support, and the app needs to manage/interpret this data</li></ol></li><li>Document oriented DBs directly store all the information as a self-contained JSON doc. This reduces impedance mismatch but loses schema enforcement. It also provides better locality of all info of a user in one place. Also good for one to many relationships.</li></ul><h3 id=many-to-one-and-many-to-many-relationships>Many to one and Many to Many relationships
<a class=anchor href=#many-to-one-and-many-to-many-relationships>#</a></h3><p>Many to one relationships (e.g. many people in seattle) don&rsquo;t fit nicely into the document model. In relational DBs, joins are easy but join support is weak in document DBs. And so, in such cases, application code might need to do the joins.</p><h3 id=hierarchical-model>Hierarchical Model
<a class=anchor href=#hierarchical-model>#</a></h3><p>Very similar to JSON DBs. Represents all data as a tree of nested records. It worked well for one to many relationships but not for many to many, and also didn&rsquo;t support joins.</p><h3 id=network-model>Network Model
<a class=anchor href=#network-model>#</a></h3><p>Proposed by CODASYL to solve issues with hierarchical model, by allowing multiple parents for a record. These links were not through foreign keys though but through pointers, but still stored on disk. A path to access a record from root along these chains of links was called <strong>access path</strong>.</p><p>Due to multiple parents of a record, apps had to keep track of all the relationships and querying/updating the DB became very complex.</p><h3 id=relational-model>Relational Model
<a class=anchor href=#relational-model>#</a></h3><p>Lays out all the data in the open and all the complexity of choosing the right indexes, ordering, etc is hidden by the query optimizer and app devs don&rsquo;t have to think about it too much.</p><h3 id=comparison-to-document-dbs>Comparison to Document DBs
<a class=anchor href=#comparison-to-document-dbs>#</a></h3><p>Document DBs are similar to hierarchical models in storing nested records for one to many relationships, while for representing many to many relationships, they are similar to relational DBs. In both cases, the related item is referenced by a unique ID called foreign key in relational model, and a <strong>document reference</strong> in document model. This ID is resolved at read time by joins or follow up queries.</p><h3 id=relational-vs-document-dbs-today>Relational v/s Document DBs today:
<a class=anchor href=#relational-vs-document-dbs-today>#</a></h3><p>Pros of Document DBs:</p><ul><li>Schema Flexibility</li><li>Better perf due to locality of data</li><li>For some apps, closer to data structures used in code</li></ul><p>Pros of Relational DBs:</p><ul><li>Better support for joins and complex queries</li></ul><p>In document model, the need for joins can be reduced by:</p><ol><li>Denormalizing the data, but app needs to do extra work to keep the denormalized data consistent</li><li>Making multiple requests to DB, but that moves the complexity to the app code and is also slower</li></ol><h3 id=schema-flexibility-in-document-model>Schema Flexibility in Document model
<a class=anchor href=#schema-flexibility-in-document-model>#</a></h3><p><strong>Schema-on-read</strong> is a more accurate term than calling document DBs schema-less, because the code reading the data applies some implicity schema but it is not enforced by the DB.</p><p>Relational DBs have schema-on-write, where the schema is enforced by the DB. This is similar to dynamic v/s static type checking paradigms.</p><p>When there is a change in schema, typically in document DBs, the app code starts writing new data with new schema and adds a check to handle the old data differently. While in relational DBs, a migration may need to be performed on old data.</p><p>Schema-on-read approach is also useful for heterogenous data where the items in the collection have different schemas.</p><h3 id=data-locality>Data Locality
<a class=anchor href=#data-locality>#</a></h3><p>Pros:</p><ul><li>Faster if large parts if document are required because don&rsquo;t need to retrieve data from multiple tables, and it exists at the same place.</li></ul><p>Cons:</p><ul><li>Need to load the whole data even if one needs a small portion.</li></ul><p>Convergence of Relational and document DBs:</p><ul><li>Most relational DBs these days support XML and JSON.</li><li>Relational DBs also have features to take advantage of locality by allowing to specify some tables&rsquo; rows to be interleaved within a parent table (Spanner/Oracle/BigTable etc allow this)</li><li>Many Document DBS support joins, or automatically resolve document references.</li></ul><h2 id=query-languages-for-data>Query Languages for Data
<a class=anchor href=#query-languages-for-data>#</a></h2><p>Relational DBS also introduced SQL, a declarative language for querying data. Declarative means that you specify:</p><ul><li>Conditions to be met</li><li>Transformations</li><li>BUT, not how to achieve this (This is done by a query optimizer)</li></ul><p>Declarative languages benefits:</p><ul><li>Easier to learn and use since they hide the implementation details of the DB engine.</li><li>DB engine can change things in background for improvements without needing the clients to change.</li><li>Easier to parallelize queries.</li></ul><p>CSS on the web is an example of a declarative language.</p><h3 id=map-reduce-querying>Map Reduce Querying
<a class=anchor href=#map-reduce-querying>#</a></h3><p>Map Reduce is a programming model for processing large amounts of data in bulk across many machines. A limited form is supported by some NoSQL DBs.</p><p>This is somewhere in between declarative and imperative languages, based on repeated calling of map and reduce functions to filter, collect & process.</p><p>For DB to run these functions anywhere, in any order and rerun on failure, they need to be pure function (i.e. use only passed-in data and not have any side effects).</p><p>Mongo DB has added support for a declarative query called <strong>aggregation pipeline</strong> which is a sequence of stages that process data records. Similar to a subset of SQL but looks more like JSON.</p><h2 id=graph-like-data-models>Graph like Data Models
<a class=anchor href=#graph-like-data-models>#</a></h2><p>Useful when primarily many to many relationships exist in the data. A graph has:</p><ul><li>Vertices (Nodes or entities)</li><li>Edges (Relationships between vertices, or arcs)</li></ul><p>Graphs can have vertices of same kind (e.g. web pages on the internet) pr different kinds (E.g. Facebook has people, location, events, etc all as vertices).</p><h3 id=property-graphs>Property Graphs
<a class=anchor href=#property-graphs>#</a></h3><p>Each vertex consists of:</p><ul><li>A unique ID</li><li>Set of outgoing edges</li><li>Set of incoming edges</li><li>Set of properties (Key value pairs)</li></ul><p>Each edge consists of:</p><ul><li>A unique ID</li><li>Vertex at which edge starts (Tail vertex)</li><li>Vertex at which edge ends (Head vertex)</li><li>Set of properties (Key value pairs)</li><li>Label to describe the relationship between the two vertices</li></ul><p>In such aa scheme, it is easy to connect different kinds of data with each other and thus the graph can evolve easily to accommodate changes.</p><p><strong>CYPHER</strong> was one of the declarative languages used for property graphs in Neo4j.</p><p>It is possible to represent this in a relational DB as well with 1 table for vertices and 1 table for edges. Thus SQL can be used to query the graph with the help of <strong>recursive common table expressions</strong> (WITH RECURSIVE) to express variable length traversal paths that may occur but it takes a lot more effort to do this.</p><p>This emphasizes the importance of picking the right data model for the problem at hand.</p><h3 id=triple-store-model-and-sparql>Triple Store Model and SPARQL
<a class=anchor href=#triple-store-model-and-sparql>#</a></h3><p>Similar to property graphs, but all info is stored in form of 3-part statements -> Subject, Predicate, Object (E.g. Jim Likes Bananas)</p><p>Subject -> Vertex
Object -></p><ul><li>Can either be a vertex (E.g. B in <code>A married to B</code>)</li><li>Can be a value in a key-value pair where predicate is the key (E.g. 33 in <code>A's age 33</code>)</li></ul><p>SPARQL is a query language for triple stores using RDF data model.</p><p>A few other discussions follow about <strong>Datalog</strong> and understanding its basics.</p></article><footer class=book-footer><div class="flex flex-wrap justify-between"></div><script>(function(){function e(e){const t=window.getSelection(),n=document.createRange();n.selectNodeContents(e),t.removeAllRanges(),t.addRange(n)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){if(window.getSelection().toString())return;e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script></footer><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><div class=book-toc-content><nav id=TableOfContents><ul><li><a href=#relational-model-vs-document-model>Relational model v/s Document model</a><ul><li><a href=#birth-of-nosql>Birth of NoSQL</a></li><li><a href=#object-relational-mismatch>Object Relational Mismatch</a></li><li><a href=#many-to-one-and-many-to-many-relationships>Many to one and Many to Many relationships</a></li><li><a href=#hierarchical-model>Hierarchical Model</a></li><li><a href=#network-model>Network Model</a></li><li><a href=#relational-model>Relational Model</a></li><li><a href=#comparison-to-document-dbs>Comparison to Document DBs</a></li><li><a href=#relational-vs-document-dbs-today>Relational v/s Document DBs today:</a></li><li><a href=#schema-flexibility-in-document-model>Schema Flexibility in Document model</a></li><li><a href=#data-locality>Data Locality</a></li></ul></li><li><a href=#query-languages-for-data>Query Languages for Data</a><ul><li><a href=#map-reduce-querying>Map Reduce Querying</a></li></ul></li><li><a href=#graph-like-data-models>Graph like Data Models</a><ul><li><a href=#property-graphs>Property Graphs</a></li><li><a href=#triple-store-model-and-sparql>Triple Store Model and SPARQL</a></li></ul></li></ul></nav></div></aside></main></body></html>