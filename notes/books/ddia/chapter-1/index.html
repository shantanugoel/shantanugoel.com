<!doctype html><html lang=en-us dir=ltr><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="Foundations of Data Systems # 3 Important Characteristics of Data Systems # Reliability: System should continue to work correctly even in the face of adversity and maintain same perf levels Scalability: As the system grows, there should be reasonable ways to deal with the growth Maintainability: Different people should be able to work on it productively across time Reliability # This can include:
Performing expected functions correctly Tolerate user mistakes or unexpected inputs Maintain good enough performance under load Prevent unauthorized access and abuse Types of faults:"><meta name=theme-color media="(prefers-color-scheme: light)" content="#ffffff"><meta name=theme-color media="(prefers-color-scheme: dark)" content="#343a40"><meta name=color-scheme content="light dark"><meta property="og:url" content="https://shantanugoel.com/notes/books/ddia/chapter-1/"><meta property="og:site_name" content="Shantanu's Notesverse"><meta property="og:title" content="Chapter 1: Foundations of Data Systems"><meta property="og:description" content="Foundations of Data Systems # 3 Important Characteristics of Data Systems # Reliability: System should continue to work correctly even in the face of adversity and maintain same perf levels Scalability: As the system grows, there should be reasonable ways to deal with the growth Maintainability: Different people should be able to work on it productively across time Reliability # This can include:
Performing expected functions correctly Tolerate user mistakes or unexpected inputs Maintain good enough performance under load Prevent unauthorized access and abuse Types of faults:"><meta property="og:locale" content="en_us"><meta property="og:type" content="article"><meta property="article:section" content="books"><title>Chapter 1: Foundations of Data Systems | Shantanu's Notesverse</title>
<link rel=manifest href=/notes/manifest.json><link rel=icon href=/notes/favicon.png><link rel=canonical href=https://shantanugoel.com/notes/books/ddia/chapter-1/><link rel=stylesheet href=/notes/book.min.309b7ed028807cdb68d8d61e26d609f48369c098dbf5e4d8c0dcf4cdf49feafc.css integrity="sha256-MJt+0CiAfNto2NYeJtYJ9INpwJjb9eTYwNz0zfSf6vw=" crossorigin=anonymous><script defer src=/notes/fuse.min.js></script><script defer src=/notes/en.search.min.5a0f7565bc56ebe2ec262f429a690368d7016d834a1649c18b3b8c1128541d72.js integrity="sha256-Wg91ZbxW6+LsJi9CmmkDaNcBbYNKFknBizuMEShUHXI=" crossorigin=anonymous></script></head><body dir=ltr><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><div class=book-menu-content><nav><h2 class=book-brand><a class="flex align-center" href=/notes/><span>Shantanu's Notesverse</span></a></h2><div class="book-search hidden"><input type=text id=book-search-input placeholder=Search aria-label=Search maxlength=64 data-hotkeys=s/><div class="book-search-spinner hidden"></div><ul id=book-search-results></ul></div><script>document.querySelector(".book-search").classList.remove("hidden")</script><ul><li><a href=https://shantanugoel.com target=_blank rel=noopener>Blog</a></li></ul><ul><li><a href=/notes/books/>Books</a><ul><li><input type=checkbox id=section-08fca0ff6f3a68fc65e738d998a1ffb8 class=toggle checked>
<label for=section-08fca0ff6f3a68fc65e738d998a1ffb8 class="flex justify-between"><a href=/notes/books/ddia/>Designing Data-Intensive Applications</a></label><ul><li><a href=/notes/books/ddia/chapter-1/ class=active>Chapter 1: Foundations of Data Systems</a></li><li><a href=/notes/books/ddia/chapter-2/>Chapter 2: Data Models and Query Languages</a></li></ul></li></ul></li><li><a href=/notes/travel/>Travel</a><ul><li><a href=/notes/travel/china/>China</a><ul></ul></li><li><a href=/notes/travel/hongkong/>Hong Kong</a><ul></ul></li><li><a href=/notes/travel/japan/>Japan</a><ul></ul></li></ul></li><li><a href=/notes/braindump/>Braindump</a><ul><li><a href=/notes/braindump/hugo-multiple-themes/>Multiple Hugo Themes For Different Paths In Same Site</a></li></ul></li></ul></nav><script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script></div></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/notes/svg/menu.svg class=book-icon alt=Menu>
</label><strong>Chapter 1: Foundations of Data Systems</strong>
<label for=toc-control><img src=/notes/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class="hidden clearfix"><nav id=TableOfContents><ul><li><a href=#3-important-characteristics-of-data-systems>3 Important Characteristics of Data Systems</a><ul><li><a href=#reliability>Reliability</a></li><li><a href=#scalability>Scalability</a></li><li><a href=#maintainability>Maintainability</a></li></ul></li></ul></nav></aside></header><article class="markdown book-article"><h1 id=foundations-of-data-systems>Foundations of Data Systems
<a class=anchor href=#foundations-of-data-systems>#</a></h1><h2 id=3-important-characteristics-of-data-systems>3 Important Characteristics of Data Systems
<a class=anchor href=#3-important-characteristics-of-data-systems>#</a></h2><ul><li><strong>Reliability</strong>: System should continue to work correctly even in the face of adversity and maintain same perf levels</li><li><strong>Scalability</strong>: As the system grows, there should be reasonable ways to deal with the growth</li><li><strong>Maintainability</strong>: Different people should be able to work on it productively across time</li></ul><h3 id=reliability>Reliability
<a class=anchor href=#reliability>#</a></h3><p>This can include:</p><ul><li>Performing expected functions correctly</li><li>Tolerate user mistakes or unexpected inputs</li><li>Maintain good enough performance under load</li><li>Prevent unauthorized access and abuse</li></ul><p>Types of faults:</p><ul><li>Hardware -> Typically mitigated by redundant hardware</li><li>Software -> Typically mitigated by thinking upfront about design and careful testing</li><li>Human error -> Typically mitigated by careful design and testing</li></ul><h3 id=scalability>Scalability
<a class=anchor href=#scalability>#</a></h3><p>This is system&rsquo;s ability to cope with increased load.</p><p>Load -> Can be described with the help of numbers we can call as <strong>load parameters</strong>. The parameters would depend on the system architecture. E.g.:</p><ul><li>Web server -> Number of requests per second</li><li>Database -> Number of read/write operations per second or read to write ratio</li><li>Chat Room -> Simultaneously active users</li><li>Cache -> Hit/miss rate</li></ul><h4 id=twitter-example>Twitter Example
<a class=anchor href=#twitter-example>#</a></h4><p>Tweet post rate -> 4.6K RPS average, 12K RPS peak
Home TL View -> 300k RPS average</p><p>Option 1:</p><p>Insert each posted tweet to a global collection. When a user views their TL, fetch all their followee&rsquo;s tweets and merge them. Simple but slow due to all the joins.</p><p>Option 2:</p><p>Maintain a cache for each user&rsquo;s TL. On a tweet post, update TL cache for all followers of tweet poster. This approach is fast on read but can become very expensive for people with large following. E.g. a user with 30 mn followers would mean 30mn writes per tweet.</p><p>Final Solution used at twitter: Hybrid approach of above 2. For most users, do 2nd option. For users with high number of followers (e.g. celebs), do option 1 (i.e. their tweets get merged into the caches at view time).</p><h4 id=performance>Performance
<a class=anchor href=#performance>#</a></h4><p>Batch processing systems (e.g. Hadoop) care more about throughput while online systems care more about response time.</p><p><strong>Latency</strong> -> duration where request is waiting to be handled</p><p><strong>Response time</strong> -> Total time spent in serving a request that a client sees (thus, including latency)</p><p>Response time is not a single number but a distribution since you&rsquo;d get slightly different response times for every request. A good metric to use while reporting perf data like response time is percentiles, not averages. This is because averages can hide outliers and also don&rsquo;t tell about how many users experienced a given response time.</p><p>Median (P50), P95, P99 etc are good metrics. High percentiles of response times are also called <strong>tail latencies</strong>.</p><p>Note: Amazon describes response time requirements for internal services in terms of P99.9, even though it affects only 1 in 1000 requests. Because often those are the users with most data because they&rsquo;ve made most purchases.</p><p>Amazon observes that a 100ms increase in response time for a request reduces sales by 1%. Others report that a 1 second slow down reduces customer satisfaction by 16%.</p><p>Note that trying to satisfy too high tail latencies is also not useful so there should be a balance of ROI.</p><p>Queueing delays are also known as <strong>head of line blocking</strong>.</p><p><strong>Load Test</strong> -> Should keep generating and sending requests without waiting for previous response to finish, to simulate the behavior of a real system where there could be queueing delays.</p><p><strong>Tail latency amplification</strong> -> When a user request results in multiple backend calls, even 1 slow call slows down the whole response & there&rsquo;s a high chance of several users experiencing this.</p><p>Approaches for coping with load:</p><ul><li>Vertical scaling -> Increase the resources of a single machine</li><li>Horizontal scaling -> Distribute load across multiple smaller machines. Also called <strong>shared-nothing</strong> architecture.</li></ul><p>Good architectures employ a pragmatic mix of both. Elasticity, or automatic scaling, is useful for unpredictable loads.</p><h3 id=maintainability>Maintainability
<a class=anchor href=#maintainability>#</a></h3><p>3 Design Principles:</p><ul><li>Operability -> Making life easy for operations</li><li>Simplicity -> Managing complexity</li><li>Evolvability -> Making change easy</li></ul><p>Accidental Complexity -> Complexity is accidental if it is not inherent in the problem that the software solves, but arises only from the implementation. Abstractions can help reduce accidental complexity. High level programming languages are abstractions too.</p></article><footer class=book-footer><div class="flex flex-wrap justify-between"></div><script>(function(){function e(e){const t=window.getSelection(),n=document.createRange();n.selectNodeContents(e),t.removeAllRanges(),t.addRange(n)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){if(window.getSelection().toString())return;e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script></footer><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><div class=book-toc-content><nav id=TableOfContents><ul><li><a href=#3-important-characteristics-of-data-systems>3 Important Characteristics of Data Systems</a><ul><li><a href=#reliability>Reliability</a></li><li><a href=#scalability>Scalability</a></li><li><a href=#maintainability>Maintainability</a></li></ul></li></ul></nav></div></aside></main></body></html>