<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Java on Shantanu Vs The World</title><link>https://shantanugoel.com/tags/java/</link><description>Recent content in Java on Shantanu Vs The World</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><managingEditor>shantanu@shantanugoel.com (Shantanu Goel)</managingEditor><webMaster>shantanu@shantanugoel.com (Shantanu Goel)</webMaster><lastBuildDate>Mon, 27 Apr 2020 19:39:50 +0530</lastBuildDate><atom:link href="https://shantanugoel.com/tags/java/index.xml" rel="self" type="application/rss+xml"/><item><title>Java "Object" in C++ using std::variant</title><link>https://shantanugoel.com/2020/04/27/java-object-cpp-std-variant/</link><pubDate>Mon, 27 Apr 2020 19:39:50 +0530</pubDate><author>shantanu@shantanugoel.com (Shantanu Goel)</author><guid>https://shantanugoel.com/2020/04/27/java-object-cpp-std-variant/</guid><description>I&amp;rsquo;m going through this brilliant book, Crafting Interpreters, these days to learn more about how interpreters are built. My attempts so far have been ameturish, as I&amp;rsquo;ve never had a formal CS course, and this looked useful to upskill my toolkit. However, the book implements the interpreter in Java (at least the first part, which I am going through now) and I&amp;rsquo;m trying to follow along in C++ instead since I don&amp;rsquo;t have much experience in Java, neither an inclination to learn it.</description><content>&lt;p>I&amp;rsquo;m going through this brilliant book, &lt;a href="https://craftinginterpreters.com/">Crafting Interpreters&lt;/a>, these days to learn more about how interpreters are built. My attempts so far have been ameturish, as I&amp;rsquo;ve never had a formal CS course, and this looked useful to upskill my toolkit. However, the book implements the interpreter in Java (at least the first part, which I am going through now) and I&amp;rsquo;m trying to follow along in C++ instead since I don&amp;rsquo;t have much experience in Java, neither an inclination to learn it. In one of the chapters, the author uses a Java &amp;ldquo;Object&amp;rdquo; class to hold the literal values that may appear in the script being parsed by the interpreter. Java docs say that:&lt;/p>
&lt;blockquote>
&lt;p>Class &lt;code>Object&lt;/code> is the root of the class hierarchy. Every class has Object as a superclass. All objects, including arrays, implement the methods of this class.&lt;/p>
&lt;/blockquote>
&lt;p>So, this threw a bit of a spanner in the works for me since C++ does not really have any equivalent class which all classes derive from. Going through the options available, I stumbled upon &lt;code>std::conditional&lt;/code> and &lt;code>std::variant&lt;/code> that could be of help. From cppreference:&lt;/p>
&lt;blockquote>
&lt;p>std::conditional&lt;/p>
&lt;p>Defined in header &amp;lt;type_traits&amp;gt;&lt;/p>
&lt;p>template&amp;lt; bool B, class T, class F &amp;gt;
struct conditional; (since C++11)&lt;/p>
&lt;p>Provides member typedef type, which is defined as T if B is true at compile time, or as F if B is false.&lt;/p>
&lt;/blockquote>
&lt;p>And&lt;/p>
&lt;blockquote>
&lt;p>std::variant&lt;/p>
&lt;p>Defined in header &amp;lt;variant&amp;gt;&lt;/p>
&lt;p>template &amp;lt;class&amp;hellip; Types&amp;gt;
class variant; (since C++17)&lt;/p>
&lt;p>The class template std::variant represents a type-safe union. An instance of std::variant at any given time either holds a value of one of its alternative types, or in the case of error&lt;/p>
&lt;/blockquote>
&lt;p>&lt;code>std::conditional&lt;/code> seems to be much more straight forward to use if you have only two types to choose from. But I needed more than 2 right now, and they could increase in future as well if I started supporting more types. Thus, I went with &lt;code>std::variant&lt;/code>. You can think of this as a safer version of a union. So, we&amp;rsquo;ll see how to achieve my goal of emulating a Java Object-like class using std::variant and the visitor pattern. Another thing I needed to do was to convert the value into a string, irrespective of which type it was, so we will see how I did that as well.&lt;/p>
&lt;p>The code is pretty straight forward. First we declare a new type alias called &lt;code>Object&lt;/code>. This refers to an std::variant which can take std::nullptr_t, std::string, a double or a bool types.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">using&lt;/span> Object &lt;span style="color:#f92672">=&lt;/span> std&lt;span style="color:#f92672">::&lt;/span>variant&lt;span style="color:#f92672">&amp;lt;&lt;/span>std&lt;span style="color:#f92672">::&lt;/span>nullptr_t, std&lt;span style="color:#f92672">::&lt;/span>string, &lt;span style="color:#66d9ef">double&lt;/span>, &lt;span style="color:#66d9ef">bool&lt;/span>&lt;span style="color:#f92672">&amp;gt;&lt;/span>;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Next we create a helper function that encapsulates our cute little trick to convert any incoming object into a string in C++ with minimal code.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">template&lt;/span> &lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">typename&lt;/span> T&lt;span style="color:#f92672">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">static&lt;/span> std&lt;span style="color:#f92672">::&lt;/span>string VisitorHelper(T x) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> std&lt;span style="color:#f92672">::&lt;/span>stringstream temp;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> temp &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> x;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> temp.str();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Now, we could create tons of boilerplate code using things like &lt;code>std::get&lt;/code>/&lt;code>std::get_if&lt;/code>/&lt;code>std::in_place_index&lt;/code> etc to start using our Object. But we want to be smart and avoid all this. So, we use a visitor pattern. You can read this awesomely simple &lt;a href="https://www.bfilipek.com/2018/06/variant.html">article&lt;/a> by Bartlomiej Filipek to understand your options better.&lt;/p>
&lt;p>We create a &lt;code>Visitor&lt;/code> struct which contains the overloads for the operator(), which will call the appropriate implementation based on the type of the value of our instance. You can create other operator overloads as well here if you need. Note that in all the cases we are calling our templatized VisitorHelper which helps in converting the value to a string and return that.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">struct&lt;/span> &lt;span style="color:#a6e22e">Visitor&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> std&lt;span style="color:#f92672">::&lt;/span>string &lt;span style="color:#66d9ef">operator&lt;/span>()(std&lt;span style="color:#f92672">::&lt;/span>nullptr_t x) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> (&lt;span style="color:#66d9ef">void&lt;/span>)x; &lt;span style="color:#75715e">// Avoid unused parameter error
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#e6db74">&amp;#34;null&amp;#34;&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> };
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> std&lt;span style="color:#f92672">::&lt;/span>string &lt;span style="color:#66d9ef">operator&lt;/span>()(&lt;span style="color:#66d9ef">double&lt;/span> x) &lt;span style="color:#66d9ef">const&lt;/span> { &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#a6e22e">VisitorHelper&lt;/span>(x); }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> std&lt;span style="color:#f92672">::&lt;/span>string &lt;span style="color:#66d9ef">operator&lt;/span>()(&lt;span style="color:#66d9ef">bool&lt;/span> x) &lt;span style="color:#66d9ef">const&lt;/span> { &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#a6e22e">VisitorHelper&lt;/span>(x); }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> std&lt;span style="color:#f92672">::&lt;/span>string &lt;span style="color:#66d9ef">operator&lt;/span>()(std&lt;span style="color:#f92672">::&lt;/span>string x) &lt;span style="color:#66d9ef">const&lt;/span> { &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#a6e22e">VisitorHelper&lt;/span>(x); }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>};
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>We can then &amp;ldquo;visit&amp;rdquo; the appropriate overload depending on the value with which it is called like so:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>std&lt;span style="color:#f92672">::&lt;/span>visit(Visitor{}, literal_);
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Combining everything together, we get to something like below (Ignore the extra code that I have for the rest of my class), and we have our very own super class &lt;code>Object&lt;/code> in C++.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">namespace&lt;/span> lox {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// TODO: Update the possible variants here as we go.
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">using&lt;/span> Object &lt;span style="color:#f92672">=&lt;/span> std&lt;span style="color:#f92672">::&lt;/span>variant&lt;span style="color:#f92672">&amp;lt;&lt;/span>std&lt;span style="color:#f92672">::&lt;/span>nullptr_t, std&lt;span style="color:#f92672">::&lt;/span>string, &lt;span style="color:#66d9ef">double&lt;/span>, &lt;span style="color:#66d9ef">bool&lt;/span>&lt;span style="color:#f92672">&amp;gt;&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">Token&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span>&lt;span style="color:#f92672">:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Token() &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">delete&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Token(&lt;span style="color:#66d9ef">const&lt;/span> TokenType type, &lt;span style="color:#66d9ef">const&lt;/span> std&lt;span style="color:#f92672">::&lt;/span>string&lt;span style="color:#f92672">&amp;amp;&lt;/span> lexeme, &lt;span style="color:#66d9ef">const&lt;/span> Object&lt;span style="color:#f92672">&amp;amp;&lt;/span> literal,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> line)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">:&lt;/span> type_(type), lexeme_(lexeme), literal_(literal), line_(line) {}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> std&lt;span style="color:#f92672">::&lt;/span>string ToString() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#e6db74">&amp;#34;Line &amp;#34;&lt;/span> &lt;span style="color:#f92672">+&lt;/span> std&lt;span style="color:#f92672">::&lt;/span>to_string(line_) &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#e6db74">&amp;#34;: &amp;#34;&lt;/span> &lt;span style="color:#f92672">+&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> TokenTypeName[&lt;span style="color:#66d9ef">static_cast&lt;/span>&lt;span style="color:#f92672">&amp;lt;&lt;/span>size_t&lt;span style="color:#f92672">&amp;gt;&lt;/span>(type_)] &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#e6db74">&amp;#34; &amp;#34;&lt;/span> &lt;span style="color:#f92672">+&lt;/span> lexeme_ &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#e6db74">&amp;#34; &amp;#34;&lt;/span> &lt;span style="color:#f92672">+&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> std&lt;span style="color:#f92672">::&lt;/span>visit(Visitor{}, literal_);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span>&lt;span style="color:#f92672">:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">const&lt;/span> TokenType type_;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">const&lt;/span> std&lt;span style="color:#f92672">::&lt;/span>string lexeme_;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">const&lt;/span> Object literal_;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> line_;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">template&lt;/span> &lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">typename&lt;/span> T&lt;span style="color:#f92672">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">static&lt;/span> std&lt;span style="color:#f92672">::&lt;/span>string VisitorHelper(T x) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> std&lt;span style="color:#f92672">::&lt;/span>stringstream temp;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> temp &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> x;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> temp.str();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">struct&lt;/span> &lt;span style="color:#a6e22e">Visitor&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> std&lt;span style="color:#f92672">::&lt;/span>string &lt;span style="color:#66d9ef">operator&lt;/span>()(std&lt;span style="color:#f92672">::&lt;/span>nullptr_t x) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> (&lt;span style="color:#66d9ef">void&lt;/span>)x; &lt;span style="color:#75715e">// Avoid unused parameter error
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#e6db74">&amp;#34;null&amp;#34;&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> };
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> std&lt;span style="color:#f92672">::&lt;/span>string &lt;span style="color:#66d9ef">operator&lt;/span>()(&lt;span style="color:#66d9ef">double&lt;/span> x) &lt;span style="color:#66d9ef">const&lt;/span> { &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#a6e22e">VisitorHelper&lt;/span>(x); }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> std&lt;span style="color:#f92672">::&lt;/span>string &lt;span style="color:#66d9ef">operator&lt;/span>()(&lt;span style="color:#66d9ef">bool&lt;/span> x) &lt;span style="color:#66d9ef">const&lt;/span> { &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#a6e22e">VisitorHelper&lt;/span>(x); }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> std&lt;span style="color:#f92672">::&lt;/span>string &lt;span style="color:#66d9ef">operator&lt;/span>()(std&lt;span style="color:#f92672">::&lt;/span>string x) &lt;span style="color:#66d9ef">const&lt;/span> { &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#a6e22e">VisitorHelper&lt;/span>(x); }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> };
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>};
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>} &lt;span style="color:#75715e">// namespace lox
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;em>&lt;em>Side note 1&lt;/em>:&lt;/em> Technically, it is not needed to create a struct for this and you can do it more concisely by creating a lambda within &lt;code>std::visit&lt;/code> instead that calls &lt;code>VisitorHelper&lt;/code> directly. I went the struct way because ultimately I want to be able to do diffferent actions depending on the type, so I need different implementations for them.&lt;/p>
&lt;p>&lt;em>&lt;em>Side note 2&lt;/em>:&lt;/em> A friend pointed out that I could use &lt;code>std::any&lt;/code> here as well. But I didn&amp;rsquo;t choose to use it because of the similar issues I mentioned earlier that it requires boilerplate for figuring out the type (e.g. in a switch case) and then getting the value after typecasting it appropriately.&lt;/p></content></item><item><title>5 Reasons I Like Linux (And 5 Why I Dislike It)</title><link>https://shantanugoel.com/2008/04/19/5-reasons-i-like-linux-and-5-why-i-dislike-it/</link><pubDate>Sat, 19 Apr 2008 20:20:40 +0000</pubDate><author>shantanu@shantanugoel.com (Shantanu Goel)</author><guid>https://shantanugoel.com/2008/04/19/5-reasons-i-like-linux-and-5-why-i-dislike-it/</guid><description>Disclaimer Notes:
I wrote this because these things just came into my mind today while I was reading about the impending “Hardy Heron” release related things and saw that there is a lot of FUD being spread still. So, thought of jotting down my likes/dislikes and not making it a linux v/s windows campaign. Though at a few places, it might be necessary to compare the two just to put things into perspective.</description><content>&lt;p>&lt;strong>Disclaimer Notes:&lt;/strong>&lt;/p>
&lt;ol>
&lt;li>
&lt;p>I wrote this because these things just came into my mind today while I was reading about the impending “Hardy Heron” release related things and saw that there is a lot of FUD being spread still. So, thought of jotting down my likes/dislikes and not making it a linux v/s windows campaign. Though at a few places, it might be necessary to compare the two just to put things into perspective.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>These are reasons why “&lt;strong>I&lt;/strong>” like/dislike Linux and not why others might like/dislike it although you might find common patterns.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Most of my recent experience is with Ubuntu these days, so most examples would be from it as well.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>These reasons are purely from an end-user’s perspective and not from a linux developer’s perspective. So, I’m not taking into factor that I can change the kernel (or most other things’) source code because “generally” I don’t.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>This post is quite long. And if you have a flame to send out my way (which you are most welcome to do), please read it in its entirety before doing so, because many things I say at some point have some caveats covered at another point.&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>&lt;strong>5 Reasons why I like Linux:&lt;/strong>&lt;/p>
&lt;p>These reasons aren’t listed in any particular order. All of them are quite important for me.&lt;/p>
&lt;p>&lt;strong>1. Light on Resources&lt;/strong>: I must say that Linux is what still keeps my more than 3 years old laptop running in a prim condition with the latest and greatest of everything from technology stand-point as well as eye-candy stuff. An example: With almost every effect of Compiz Fusion turned on, hordes of screenlets and AWN enabled, an Apache/MySQL/PHP based server running, and a dozen of other applications (firefox, nautilus, terminal, GIMP, RhythmBox, Open Office Word Processor, VLC player, etc) open, my setup consumes around 500 MB of RAM. While on the other hand, if I was using Vista, It’d have demanded atleast 1 GB of RAM just to run Aero, forget about the rest of the things.&lt;/p>
&lt;p>&lt;strong>2. Cost&lt;/strong>: This is a big factor for me. Almost everything is free or atleast has a free alternative available. Most of the times I’ve found these free software to be much better than commercial software in terms of feature sets as well as stability. But even otherwise, when there are cases where the free alternative a bit lagging as compared to the commercial one (e.g. GIMP v/s Photoshop), I haven’t felt that my needs have ever outgrown the free software.&lt;/p>
&lt;p>&lt;strong>3. Ease of Use&lt;/strong>: Doing “stuff” on linux is just so easy. By “stuff”, I mean everything from doing some normal day chores, downloading files, customizing things, automating routine tasks, etc. The backbone for this is “the terminal” (not the movie :P). I can do almost anything I want from the console. It not only saves me time and frustration in executing a program, waiting for the GUI to load and then go through a series of clicks but also allows me to batch up everything into one pretty little command. Moreover, every thing has so many options that I can configure to my liking. (More on the “options” later below)&lt;/p>
&lt;p>&lt;strong>4. Getting Software&lt;/strong>: Getting software couldn’t be more easy.&lt;/p>
&lt;ul>
&lt;li>
&lt;p>It generally involves typing in “sudo apt-get install &lt;!-- raw HTML omitted -->”, pressing enter, and that’s it. The latest version is ready to roll on your machine.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Reboots are minimal. Even after thinking for quite long, it’s very hard to recall any time when I had to “log-off” my system (let alone reboot) after installing a software (or even a driver)&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Updates are automatic, and not just for the OS or a few core components, but for all the software that I installed through repositories (but not for the ones which I installed from my local deb’s or compilations, which is understandable of course)&lt;/p>
&lt;/li>
&lt;li>
&lt;p>The latest fixes/patches are available very quickly. Moreover, the revision cycle for most distros lies between 6–12 months and hence, even a complete desktop upgrade is quickly available as well (as compared to the 7 year period after which Vista came out). You can even “upgrade” to the latest distro revision without having to wipe everything, though I generally prefer a clean install.&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>5. Security&lt;/strong>:Now, I agree with everyone that the reason why we don’t see many viruses for linux is because the user base is very less as compared to other OS’s but I also believe that this is not the “only” reason.&lt;/p>
&lt;ul>
&lt;li>
&lt;p>The thing is that since most of the software is open source, so exploits are found quite quickly and patched and released rapidly. While in a closed source environments, even if a white hat reports it, the exploits go on un-noticed, un-worked upon by the developers (A good example is the recent falling of Vista during the “Pwn to Own” contest because of a known but unpatched vulnerability by Adobe, not a fault of Vista in this case though but you get my drift).&lt;/p>
&lt;/li>
&lt;li>
&lt;p>The security model otherwise is also quite tight and its very hard for someone to exploit it till the time you use common sense along with it. (A linux virus can easily wipe ur “/home” without acqurining root permissions).&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>5 Reasons why I dislike Linux&lt;/strong>&lt;/p>
&lt;p>These reasons irk me the most but aren’t enough for to make me move away from Linux. I mention them because getting them right would make my Linux expereince that much more joyful and probably others feels the same too. Moreover, this is not a gripe and is not a command/order to “the Linux guys” out there to fix it, because linux is of, by and for the community. And being a part of this community, I share the burden of this equally and would like to help out in making it better in whatever ways possible, developing, testing, suggesting things.&lt;/p>
&lt;p>**1. Getting Software: **I had mentioned about how easy it is to get software from most distros’ repositories with a single command. However, getting and installing software is also a challenge that many people face in linux. After sometime your particular version of the distro stops updating the software and will include only security fixes and such. Now, there are many good people who would backport software for your version but not all the time. You can download pacakges off the internet (debs’ for ubuntu) but they might not work because of too many inter-mingled dependencies. Compiling is another option but many times, it can spiral out of hand. I hope we can better softwares like GDebi that could make this much more easier.&lt;/p>
&lt;p>**2. Options: **Earlier I listed having so many options as one of my reasons to like Linux. But, sometimes, too many options tend to get to my head. This gets even more difficult when you have too many choices but no clue about what means what and which one is the best. However, the community is continously trying to make this right. A lot of documentation projects are going on, and the mailing lists, IRC networks and other forums also give out a lot of information. Especially for Ubuntu, I find a huge community based support system which always helps me out. (PS – The Ubuntu Forums are the nicest forums you’ll ever come across. I am yet to come across a post that contains words like “RTFM” or “n00b”)&lt;/p>
&lt;p>&lt;strong>3. Ease Of Use:&lt;/strong> Some times, just some times, the lack of a GUI for common things irks me and I wish in respect of a few things (read wi-fi) that things could “just work”. But I guess this is a trade-off that I can live with, and moreover this situation is also improving especilly due to the efforts taken by Ubuntu, Mandriva, Fedora, GNOME and KDE. (Special thanks to nm-applet ;-) ). Moreover, Hardy Heron, b43 and the latest linux kernels promise to solve the wi-fi setup issues.&lt;/p>
&lt;p>&lt;strong>4. Browsing&lt;/strong>: The browsing experience on linux isn’t too great. But this is not a fault of Linux as such. This is due to companies providing adequate linux support (e.g. java plugins for 64 bit) and too many sites optimizing their code for IE. But again, there is hope for this as we can already run IE on linux (IEs4Linux) plus SUN has promised a 64 bit java firefox plugin with the next JRE.&lt;/p>
&lt;p>**5. Drivers: **This is again due to companies not giving proper linux support for their hardware and not even releasing their hardware details for the OSS community to develop their own drivers. However, I can understand that giving out hardware details might not be an option for these companies considering the competition, and also proper software support might be a bit unfeasible due to a smaller consumer base. But again, more and more companies are seeing the light now and releasing proper drivers for linux, with Nvidia and ATi taking the lead (When will Creative listen?). And a special thanks to the OSS community for making working drivers despite all this.&lt;/p>
&lt;p>&lt;strong>So, this is it. After reading back through what I just wrote, I am dead sure that I will stick to Linux as the trade-offs are too meagre for me. Will you?&lt;/strong>&lt;/p></content></item></channel></rss>