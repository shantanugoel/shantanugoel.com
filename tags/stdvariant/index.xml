<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Std::variant on Shantanu Vs The World</title><link>https://shantanugoel.com/tags/stdvariant/</link><description>Recent content in Std::variant on Shantanu Vs The World</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><managingEditor>shantanu@shantanugoel.com (Shantanu Goel)</managingEditor><webMaster>shantanu@shantanugoel.com (Shantanu Goel)</webMaster><lastBuildDate>Mon, 27 Apr 2020 19:39:50 +0530</lastBuildDate><atom:link href="https://shantanugoel.com/tags/stdvariant/index.xml" rel="self" type="application/rss+xml"/><item><title>Java "Object" in C++ using std::variant</title><link>https://shantanugoel.com/2020/04/27/java-object-cpp-std-variant/</link><pubDate>Mon, 27 Apr 2020 19:39:50 +0530</pubDate><author>shantanu@shantanugoel.com (Shantanu Goel)</author><guid>https://shantanugoel.com/2020/04/27/java-object-cpp-std-variant/</guid><description>I&amp;rsquo;m going through this brilliant book, Crafting Interpreters, these days to learn more about how interpreters are built. My attempts so far have been ameturish, as I&amp;rsquo;ve never had a formal CS course, and this looked useful to upskill my toolkit. However, the book implements the interpreter in Java (at least the first part, which I am going through now) and I&amp;rsquo;m trying to follow along in C++ instead since I don&amp;rsquo;t have much experience in Java, neither an inclination to learn it.</description><content>&lt;p>I&amp;rsquo;m going through this brilliant book, &lt;a href="https://craftinginterpreters.com/">Crafting Interpreters&lt;/a>, these days to learn more about how interpreters are built. My attempts so far have been ameturish, as I&amp;rsquo;ve never had a formal CS course, and this looked useful to upskill my toolkit. However, the book implements the interpreter in Java (at least the first part, which I am going through now) and I&amp;rsquo;m trying to follow along in C++ instead since I don&amp;rsquo;t have much experience in Java, neither an inclination to learn it. In one of the chapters, the author uses a Java &amp;ldquo;Object&amp;rdquo; class to hold the literal values that may appear in the script being parsed by the interpreter. Java docs say that:&lt;/p>
&lt;blockquote>
&lt;p>Class &lt;code>Object&lt;/code> is the root of the class hierarchy. Every class has Object as a superclass. All objects, including arrays, implement the methods of this class.&lt;/p>
&lt;/blockquote>
&lt;p>So, this threw a bit of a spanner in the works for me since C++ does not really have any equivalent class which all classes derive from. Going through the options available, I stumbled upon &lt;code>std::conditional&lt;/code> and &lt;code>std::variant&lt;/code> that could be of help. From cppreference:&lt;/p>
&lt;blockquote>
&lt;p>std::conditional&lt;/p>
&lt;p>Defined in header &amp;lt;type_traits&amp;gt;&lt;/p>
&lt;p>template&amp;lt; bool B, class T, class F &amp;gt;
struct conditional; (since C++11)&lt;/p>
&lt;p>Provides member typedef type, which is defined as T if B is true at compile time, or as F if B is false.&lt;/p>
&lt;/blockquote>
&lt;p>And&lt;/p>
&lt;blockquote>
&lt;p>std::variant&lt;/p>
&lt;p>Defined in header &amp;lt;variant&amp;gt;&lt;/p>
&lt;p>template &amp;lt;class&amp;hellip; Types&amp;gt;
class variant; (since C++17)&lt;/p>
&lt;p>The class template std::variant represents a type-safe union. An instance of std::variant at any given time either holds a value of one of its alternative types, or in the case of error&lt;/p>
&lt;/blockquote>
&lt;p>&lt;code>std::conditional&lt;/code> seems to be much more straight forward to use if you have only two types to choose from. But I needed more than 2 right now, and they could increase in future as well if I started supporting more types. Thus, I went with &lt;code>std::variant&lt;/code>. You can think of this as a safer version of a union. So, we&amp;rsquo;ll see how to achieve my goal of emulating a Java Object-like class using std::variant and the visitor pattern. Another thing I needed to do was to convert the value into a string, irrespective of which type it was, so we will see how I did that as well.&lt;/p>
&lt;p>The code is pretty straight forward. First we declare a new type alias called &lt;code>Object&lt;/code>. This refers to an std::variant which can take std::nullptr_t, std::string, a double or a bool types.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">using&lt;/span> Object &lt;span style="color:#f92672">=&lt;/span> std&lt;span style="color:#f92672">::&lt;/span>variant&lt;span style="color:#f92672">&amp;lt;&lt;/span>std&lt;span style="color:#f92672">::&lt;/span>nullptr_t, std&lt;span style="color:#f92672">::&lt;/span>string, &lt;span style="color:#66d9ef">double&lt;/span>, &lt;span style="color:#66d9ef">bool&lt;/span>&lt;span style="color:#f92672">&amp;gt;&lt;/span>;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Next we create a helper function that encapsulates our cute little trick to convert any incoming object into a string in C++ with minimal code.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">template&lt;/span> &lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">typename&lt;/span> T&lt;span style="color:#f92672">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">static&lt;/span> std&lt;span style="color:#f92672">::&lt;/span>string VisitorHelper(T x) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> std&lt;span style="color:#f92672">::&lt;/span>stringstream temp;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> temp &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> x;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> temp.str();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Now, we could create tons of boilerplate code using things like &lt;code>std::get&lt;/code>/&lt;code>std::get_if&lt;/code>/&lt;code>std::in_place_index&lt;/code> etc to start using our Object. But we want to be smart and avoid all this. So, we use a visitor pattern. You can read this awesomely simple &lt;a href="https://www.bfilipek.com/2018/06/variant.html">article&lt;/a> by Bartlomiej Filipek to understand your options better.&lt;/p>
&lt;p>We create a &lt;code>Visitor&lt;/code> struct which contains the overloads for the operator(), which will call the appropriate implementation based on the type of the value of our instance. You can create other operator overloads as well here if you need. Note that in all the cases we are calling our templatized VisitorHelper which helps in converting the value to a string and return that.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">struct&lt;/span> &lt;span style="color:#a6e22e">Visitor&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> std&lt;span style="color:#f92672">::&lt;/span>string &lt;span style="color:#66d9ef">operator&lt;/span>()(std&lt;span style="color:#f92672">::&lt;/span>nullptr_t x) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> (&lt;span style="color:#66d9ef">void&lt;/span>)x; &lt;span style="color:#75715e">// Avoid unused parameter error
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#e6db74">&amp;#34;null&amp;#34;&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> };
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> std&lt;span style="color:#f92672">::&lt;/span>string &lt;span style="color:#66d9ef">operator&lt;/span>()(&lt;span style="color:#66d9ef">double&lt;/span> x) &lt;span style="color:#66d9ef">const&lt;/span> { &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#a6e22e">VisitorHelper&lt;/span>(x); }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> std&lt;span style="color:#f92672">::&lt;/span>string &lt;span style="color:#66d9ef">operator&lt;/span>()(&lt;span style="color:#66d9ef">bool&lt;/span> x) &lt;span style="color:#66d9ef">const&lt;/span> { &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#a6e22e">VisitorHelper&lt;/span>(x); }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> std&lt;span style="color:#f92672">::&lt;/span>string &lt;span style="color:#66d9ef">operator&lt;/span>()(std&lt;span style="color:#f92672">::&lt;/span>string x) &lt;span style="color:#66d9ef">const&lt;/span> { &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#a6e22e">VisitorHelper&lt;/span>(x); }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>};
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>We can then &amp;ldquo;visit&amp;rdquo; the appropriate overload depending on the value with which it is called like so:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>std&lt;span style="color:#f92672">::&lt;/span>visit(Visitor{}, literal_);
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Combining everything together, we get to something like below (Ignore the extra code that I have for the rest of my class), and we have our very own super class &lt;code>Object&lt;/code> in C++.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">namespace&lt;/span> lox {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// TODO: Update the possible variants here as we go.
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">using&lt;/span> Object &lt;span style="color:#f92672">=&lt;/span> std&lt;span style="color:#f92672">::&lt;/span>variant&lt;span style="color:#f92672">&amp;lt;&lt;/span>std&lt;span style="color:#f92672">::&lt;/span>nullptr_t, std&lt;span style="color:#f92672">::&lt;/span>string, &lt;span style="color:#66d9ef">double&lt;/span>, &lt;span style="color:#66d9ef">bool&lt;/span>&lt;span style="color:#f92672">&amp;gt;&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">Token&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span>&lt;span style="color:#f92672">:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Token() &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">delete&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Token(&lt;span style="color:#66d9ef">const&lt;/span> TokenType type, &lt;span style="color:#66d9ef">const&lt;/span> std&lt;span style="color:#f92672">::&lt;/span>string&lt;span style="color:#f92672">&amp;amp;&lt;/span> lexeme, &lt;span style="color:#66d9ef">const&lt;/span> Object&lt;span style="color:#f92672">&amp;amp;&lt;/span> literal,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> line)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">:&lt;/span> type_(type), lexeme_(lexeme), literal_(literal), line_(line) {}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> std&lt;span style="color:#f92672">::&lt;/span>string ToString() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#e6db74">&amp;#34;Line &amp;#34;&lt;/span> &lt;span style="color:#f92672">+&lt;/span> std&lt;span style="color:#f92672">::&lt;/span>to_string(line_) &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#e6db74">&amp;#34;: &amp;#34;&lt;/span> &lt;span style="color:#f92672">+&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> TokenTypeName[&lt;span style="color:#66d9ef">static_cast&lt;/span>&lt;span style="color:#f92672">&amp;lt;&lt;/span>size_t&lt;span style="color:#f92672">&amp;gt;&lt;/span>(type_)] &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#e6db74">&amp;#34; &amp;#34;&lt;/span> &lt;span style="color:#f92672">+&lt;/span> lexeme_ &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#e6db74">&amp;#34; &amp;#34;&lt;/span> &lt;span style="color:#f92672">+&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> std&lt;span style="color:#f92672">::&lt;/span>visit(Visitor{}, literal_);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span>&lt;span style="color:#f92672">:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">const&lt;/span> TokenType type_;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">const&lt;/span> std&lt;span style="color:#f92672">::&lt;/span>string lexeme_;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">const&lt;/span> Object literal_;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> line_;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">template&lt;/span> &lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">typename&lt;/span> T&lt;span style="color:#f92672">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">static&lt;/span> std&lt;span style="color:#f92672">::&lt;/span>string VisitorHelper(T x) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> std&lt;span style="color:#f92672">::&lt;/span>stringstream temp;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> temp &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> x;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> temp.str();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">struct&lt;/span> &lt;span style="color:#a6e22e">Visitor&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> std&lt;span style="color:#f92672">::&lt;/span>string &lt;span style="color:#66d9ef">operator&lt;/span>()(std&lt;span style="color:#f92672">::&lt;/span>nullptr_t x) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> (&lt;span style="color:#66d9ef">void&lt;/span>)x; &lt;span style="color:#75715e">// Avoid unused parameter error
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#e6db74">&amp;#34;null&amp;#34;&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> };
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> std&lt;span style="color:#f92672">::&lt;/span>string &lt;span style="color:#66d9ef">operator&lt;/span>()(&lt;span style="color:#66d9ef">double&lt;/span> x) &lt;span style="color:#66d9ef">const&lt;/span> { &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#a6e22e">VisitorHelper&lt;/span>(x); }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> std&lt;span style="color:#f92672">::&lt;/span>string &lt;span style="color:#66d9ef">operator&lt;/span>()(&lt;span style="color:#66d9ef">bool&lt;/span> x) &lt;span style="color:#66d9ef">const&lt;/span> { &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#a6e22e">VisitorHelper&lt;/span>(x); }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> std&lt;span style="color:#f92672">::&lt;/span>string &lt;span style="color:#66d9ef">operator&lt;/span>()(std&lt;span style="color:#f92672">::&lt;/span>string x) &lt;span style="color:#66d9ef">const&lt;/span> { &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#a6e22e">VisitorHelper&lt;/span>(x); }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> };
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>};
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>} &lt;span style="color:#75715e">// namespace lox
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;em>&lt;em>Side note 1&lt;/em>:&lt;/em> Technically, it is not needed to create a struct for this and you can do it more concisely by creating a lambda within &lt;code>std::visit&lt;/code> instead that calls &lt;code>VisitorHelper&lt;/code> directly. I went the struct way because ultimately I want to be able to do diffferent actions depending on the type, so I need different implementations for them.&lt;/p>
&lt;p>&lt;em>&lt;em>Side note 2&lt;/em>:&lt;/em> A friend pointed out that I could use &lt;code>std::any&lt;/code> here as well. But I didn&amp;rsquo;t choose to use it because of the similar issues I mentioned earlier that it requires boilerplate for figuring out the type (e.g. in a switch case) and then getting the value after typecasting it appropriately.&lt;/p></content></item></channel></rss>