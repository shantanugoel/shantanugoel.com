<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>C on Shantanu Vs The World</title><link>https://shantanugoel.com/tags/c/</link><description>Recent content in C on Shantanu Vs The World</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><managingEditor>shantanu@shantanugoel.com (Shantanu Goel)</managingEditor><webMaster>shantanu@shantanugoel.com (Shantanu Goel)</webMaster><lastBuildDate>Mon, 25 Feb 2013 18:48:21 +0000</lastBuildDate><atom:link href="https://shantanugoel.com/tags/c/index.xml" rel="self" type="application/rss+xml"/><item><title>The 80 Column Coding Rule</title><link>https://shantanugoel.com/2013/02/25/the-80-column-coding-rule/</link><pubDate>Mon, 25 Feb 2013 18:48:21 +0000</pubDate><author>shantanu@shantanugoel.com (Shantanu Goel)</author><guid>https://shantanugoel.com/2013/02/25/the-80-column-coding-rule/</guid><description>I&amp;rsquo;ve followed the 80 column rule almost always when I code, i.e., I keep a soft limit of keeping my lines of my code limited to 80 characters max. unless breaking up the line really messes up the readability of the code.
I was asked recently why do I bother now in this age of 24&amp;quot; widescreen monitors (and above) with resolutions of 720p at the bare minimum. I could certainly afford to have more than double that limit staring back at me from the screen without overflowing.</description><content>&lt;p>I&amp;rsquo;ve followed the 80 column rule almost always when I code, i.e., I keep a soft limit of keeping my lines of my code limited to 80 characters max. unless breaking up the line really messes up the readability of the code.&lt;/p>
&lt;p>I was asked recently why do I bother now in this age of 24&amp;quot; widescreen monitors (and above) with resolutions of 720p at the bare minimum. I could certainly afford to have more than double that limit staring back at me from the screen without overflowing. Then, am I just being pedantic in following this religiously? Am I not wasting precious screen real estate by doing this?&lt;/p>
&lt;p>Well, NO. The reason I still do it is I can use that real estate for much better purposes while not breaking a sweat (and my neck) while reading long horizontal lines of code. It is still much easier to keep the code size limited horizontally within your immediate focus of vision and you can use the rest of the horizontal space for things like having a directory tree or a database of tags showing. But I keep these extras ready at the whim of a button (mapped to key combos in vim) and the most I use it for is having two (or more) files open simultaneously in vim splits to make the code easier to understand or even write. Many times, what I am reading/writing needs me to back and forth between a few files and I can keep them all open using the big screens if I limit my horizontal code size in each file.&lt;/p>
&lt;p>I wasn&amp;rsquo;t still able to convince the person of my self-imposed rule but maybe I&amp;rsquo;m wrong? What do you follow?&lt;/p></content></item><item><title>Slow Updates And A Small Nugget Post</title><link>https://shantanugoel.com/2009/01/13/slow-updates-and-a-small-nugget-post/</link><pubDate>Tue, 13 Jan 2009 04:47:00 +0000</pubDate><author>shantanu@shantanugoel.com (Shantanu Goel)</author><guid>https://shantanugoel.com/2009/01/13/slow-updates-and-a-small-nugget-post/</guid><description>Many readers of this blog have written to me for the slow updates. I apologize for the same. I’ve been swamped by loads of work for quite some time now and haven’t been able to write anything here or update any of my projects, though I have loads of new hacks and tricks that I would write once I’m free and lots in store for most of the projects as well in form of bug fixes and new features.</description><content>&lt;p>Many readers of this blog have written to me for the slow updates. I apologize for the same. I’ve been swamped by loads of work for quite some time now and haven’t been able to write anything here or update any of my projects, though I have loads of new hacks and tricks that I would write once I’m free and lots in store for most of the projects as well in form of bug fixes and new features. So, hang in there :)&lt;/p>
&lt;p>Meanwhile, take a look at this post ( &lt;a href="http://www.safercode.com/blog/2008/10/14/int-main-vs-void-main.html">int Main() vs void main()&lt;/a> )that I had made some time ago at another blog of mine ( &lt;a href="http://www.safercode.com/blog/">Safer Code - Secure Coding In C \ C++ And More&lt;/a> ). Why I’m telling you about this post is that it is a really important post useful for every C / C++ developer and recently it got featured on LinuxToday and Lxer, after which there is a very interesting discussion going on to discuss the various aspects related to it.&lt;/p>
&lt;p>Do check out the rest of the blog as well. It is about tit-bits of security, optimization and performance of your code and in a manner and amount that you can easily digest. What’s best is that it is delivered regularly at a slow pace that everyone can follow :). So, what are you waiting for? Add it to your feed reader or choose to get the updates through e-mail and do let me know in the comments there how you like it.&lt;/p></content></item><item><title>Want To Program Smartly In C? Use GLib</title><link>https://shantanugoel.com/2008/05/03/smart-programming-in-c-using-glib/</link><pubDate>Sat, 03 May 2008 15:30:16 +0000</pubDate><author>shantanu@shantanugoel.com (Shantanu Goel)</author><guid>https://shantanugoel.com/2008/05/03/smart-programming-in-c-using-glib/</guid><description>GLib - An Introduction:
GLib is a utility library for C, which augments the standard C library in several purposeful ways to make your life that much easier while programming. GLib has the following things to offer you:
**1. Portability: **The main issue that haunts any C developer is the portability of code. One cannot rely on the standard C library for this as you may find many functions that work differently under different platforms are aren&amp;rsquo;t there at all sometimes.</description><content>&lt;p>&lt;strong>GLib - An Introduction:&lt;/strong>&lt;/p>
&lt;p>&lt;a href="http://library.gnome.org/devel/glib/">GLib&lt;/a> is a utility library for C, which augments the standard C library in several purposeful ways to make your life that much easier while programming. GLib has the following things to offer you:&lt;/p>
&lt;p>**1. Portability: **The main issue that haunts any C developer is the portability of code. One cannot rely on the standard C library for this as you may find many functions that work differently under different platforms are aren&amp;rsquo;t there at all sometimes. GLib ensures that the all the functionality exposed by it remains consistent across platforms, so that you can rest assured that your code will work the way its supposed to work irrespective of the Operating System it&amp;rsquo;s being used for (Of course, this assumes that you have ensured about portability aspects of your non-GLib related source code). Moreover, GLib is available for a vast array of contemporary Operating Systems including GNU/Linux, Microsoft Windows and Mac OS X.&lt;/p>
&lt;p>**2. Security: **Though you still need to be careful about things like freeing allocated memories properly, etc but GLib does ensure that all its functionality is secure. Moreover, GLib has a policy of ensuring that all its functions are threadsafe. This saves you from a lot of checks and balances and locks and scheduling considerations if you had written all this yourself.&lt;/p>
&lt;p>&lt;strong>3. Useful Data Types:&lt;/strong> GLib exposes a lot of data types. Some are very basic that maintain portability across OS&amp;rsquo;s and 32-bit and 64-bit systems. e.g. you can rest assured that gint32 will always be 32 bit and gint64 will always be 64 bit data types.&lt;/p>
&lt;p>Apart from this, it also provides a lot of derived data types e.g. singly linked lists, doubly linked lists, hash tables, stacks, queues, trees, and much more. It&amp;rsquo;d basically cover most of you data structure needs that you&amp;rsquo;d have otherwise had to implement yourselves. And it also provides helper functions that makes working with them so much more easier. If you have ever used Perl, and have wished that C programming could be a bit faster like it, you will be pleasantly surprised.&lt;/p>
&lt;p>**4. Utility Functions: **GLib also provides various utility functions to ease out your manipulation of data. Some of the functions are meant as more secure and portable replacements for those provided with standard C library, while rest are meant to provide other useful functionality which you earlier had to implement in your code. Some of the major areas covered by GLib&amp;rsquo;s utility functions are String manipulation, character set manipulation and conversion (including unicode and base64), using regular expressions, file manipulation, shell functions, config file parsing (my favourite), etc.&lt;/p>
&lt;p>&lt;strong>End Note:&lt;/strong> I can understand that there would be a lot of people who believe that use of GLib is dumbing down programming in C. After all, we take pride being in control of our code and this is why we love progrmming in C because we have options to do things in our own way. Yes, that is all true but there comes a time where you&amp;rsquo;d like to spend more time in developing the core functionality of your app, or focus more on giving a rapid shape to your new idea, rather than reinventing the wheel and fumbling around with writing the helper functions. So, keeping that in mind I believe GLib is wonderful piece of code that has enabled me to churn out new apps that much faster.&lt;/p></content></item></channel></rss>